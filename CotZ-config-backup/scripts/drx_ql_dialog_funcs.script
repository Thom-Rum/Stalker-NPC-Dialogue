--=============================================================
--
-- Questlines Dialog Functions (drx_ql_dialog_funcs.script)
--	CoC 1.5b r4 - DoctorX Questlines 2.0
--
--	Created by: DoctorX
--	Last revised: November 16, 2019
--
--=============================================================


-- ________________________________________________________________________________________________
-- TASK STORAGE ARRAYS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- Completed Change Factions Tasks Global Array
--
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	November 17, 2017
--
-- ------------------------------------------------------------------------------------------------

-- Storage for completed storyline tasks:
drx_ql_completed_sl_tasks = {}

-- Storage for completed change factions tasks:
drx_ql_completed_cf_tasks = {}

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- Current Change Factions Tasks Global Array
--
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	November 17, 2017
--
-- ------------------------------------------------------------------------------------------------

-- Storage for currently active storyline tasks:
drx_ql_current_sl_tasks = {}

-- Storage for currently active change factions tasks:
drx_ql_current_cf_tasks = {}

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- Safecracker Task Global Vars
--
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	August 30, 2018
--
-- ------------------------------------------------------------------------------------------------

-- Array to store safecracker task actor reward items:
drx_ql_safecracker_rewards = {}

-- Current safecracker item the npc has pulled from the case:
drx_ql_safecracker_current_item = nil

-- Number of safecracker reward items currently allocated to actor:
drx_ql_safecracker_actor_items = 0

-- Number of safecracker reward items currently allocated to npc:
drx_ql_safecracker_npc_items = 0

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- GIVE TASK FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_give_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Gives the player the task currently stored with the npc
--		- Modification of dialogs.npc_give_task (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_give_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_current_honcho (type: string, npc name)
--			Current meet honcho target npc
--		drx_ql_task_giver_{npc_id} (type: int)
--			- Count of currently active tasks the npc has given the player
--		drx_ql_hostage_giver_{npc_id} (type: bool)
--			- Flag indicating whether or not the npc is a hostage task giver
--		drx_ql_hostage_giver_needed (type: bool)
--			- Flag indicating whether or not the current npc needs to be registered as a hostage task giver
--
--	Return value (type: bool):
--		Returns true on success
--		Returns false on failure
--
--	Notes:
--		- Task given is the currently stored task in axr_task_manager.available_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified January 30, 2019
-- ------------------------------------------------------------------------------------------------

-- Give player currently stored task:
function drx_ql_give_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to give current task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to give current task, npc id is invalid" )
		return false
	end

	-- Get the currently stored task from the npc:
	local task_id = (axr_task_manager.available_tasks[npc_id] and axr_task_manager.available_tasks[npc_id][1])
	if ( not task_id) then
		printf( "DRX QL Error: No stored tasks available for %s", npc_id )
		return false
	end

	-- Format task giver section name:
	local npc_name
	if ( npc:section( ) == "m_trader" ) then
		npc_name = npc:name( )
	else
		npc_name = npc:section( )
	end

	-- Give the player the current task:
	task_manager.get_task_manager( ):give_task( task_id, npc_id )
	if ( string.find( task_id, "_sl_task_" ) ) then
		disable_info( string.format( "drx_ql_meet_honcho_%s", npc_name ) )
		printf( "DRX QL: Storyline task %s started", task_id )
	elseif ( string.find( task_id, "_meet_task_" ) ) then
		if ( not string.find( task_id, npc_name ) ) then
			disable_info( string.format( "drx_ql_meet_honcho_%s", npc_name ) )
		end
		printf( "DRX QL: Meet task %s started", task_id )
	elseif ( string.find( task_id, "simulation_task_" ) ) then
		printf( "DRX QL: Simulation task %s started", task_id )
	else
		printf( "DRX QL: Dynamic task %s started", task_id )
	end

	-- Register current task giver:
	if ( not string.find( task_id, "_meet_task_" ) ) then
		local giver_task_count = (utils.load_var( db.actor, string.format( "drx_ql_task_giver_%s", npc_id ), 0 ) + 1)
		utils.save_var( db.actor, string.format( "drx_ql_task_giver_%s", npc_id ), giver_task_count )
		printf( "DRX QL: drx_ql_task_giver_%s registered (%s outstanding)", npc_id, giver_task_count )
	end

	-- Register hostage task giver:
	if ( utils.load_var( db.actor, "drx_ql_hostage_giver_needed", false ) ) then
		utils.save_var( db.actor, string.format( "drx_ql_hostage_giver_%s", npc_id ), true )
		utils.save_var( db.actor, "drx_ql_hostage_giver_needed", false )
		printf( "DRX QL: drx_ql_hostage_giver_%s registered", npc_id )
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- GENERATE TASK FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_generate_sl_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates a storyline task during a dialog
--		- Modification of axr_task_manager.generate_available_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_generate_sl_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_current_npc_speaker_id (type: npc id)
--			- Id of the current npc the actor is speaking to
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[sim_task_props]
--				task_weight_mult (type: int)
--					- Multiplier to apply to task weights
--			[defector_task_settings]
--				defector_task (type: string, task section name)
--					- Task to give containing defector dialog
--		misc\drx_ql_tasks\drx_ql_tasks_*.ltx
--			[{task_id}]
--				link_back_info (type: string)
--					- Infoportion to check to allow task as linked from task
--				link_info (type: string)
--					- Infoportion to give to lead to a linked task
--				weight (type: int)
--					- Higher numbers increase the probability the task will be offered (recommended: 1-3) (optional; default = 1)
--
--	Return value (type: bool):
--		Returns true on success
--		Returns false on failure
--
--	Notes:
--		- Generated task is stored in axr_task_manager.available_tasks[{npc_id}][1]
--		- If a valid storyline task cannot be found, a meet honcho task will be generated instead
--		- Storyline tasks are defined in configs\misc\drx_ql_tasks\drx_ql_tasks_*.ltx
--		- Task section names for storyline tasks must follow this format: drx_ql_{npc_faction}_sl_task_{x}
--			{npc_faction} = NPC faction
--			{x} = sequential number starting at 1
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 02, 2019
-- ------------------------------------------------------------------------------------------------

-- Generate storyline task:
function drx_ql_generate_sl_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate storyline task, db.actor not available" )
		return false
	end

	-- Get settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate sl task, cannot locate ini file" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate storyline task, npc id is invalid" )
		return false
	end
	utils.save_var( db.actor, "drx_ql_current_npc_speaker_id", npc_id )

	-- Remove current available tasks for the npc:
	axr_task_manager.available_tasks[npc_id] = iempty_table( axr_task_manager.available_tasks[npc_id] )

	-- Give defector dialog if actor defected from Monolith:
	if ( has_alife_info( "drx_ql_info_defected_monolith" ) ) then
		disable_info( "drx_ql_info_defected_monolith" )
		local defector_task = ini:r_string_ex( "defector_task_settings", "defector_task" )
		if ( not defector_task ) then
			printf( "DRX QL Error: Unable to generate defector task, no defector task specified" )
		else
			axr_task_manager.available_tasks[npc_id][1] = defector_task
			return true
		end
	end

	-- Check if there is a finished sl task that leads to a linked task:
	local linked_task = false
	local link_info
	if ( (drx_ql_completed_sl_tasks) and (drx_ql_completed_sl_tasks[npc_id]) and (drx_ql_completed_sl_tasks[npc_id][1]) ) then
		linked_task = true
		link_info = task_manager.task_ini:r_string_ex( drx_ql_completed_sl_tasks[npc_id][1], "link_info" )
	end

	-- Get npc faction:
	local npc_faction = drx_ql_npc_faction( npc )

	-- Generate list of valid tasks:
	local valid_task_list = {}
	local task_section_name = string.format( "drx_ql_%s_sl_task", npc_faction )
	local task_info = task_manager.get_task_manager( ).task_info
	local task_number = 1
	local task_id = string.format( "%s_%s", task_section_name, task_number )
	local weight_mult = (ini:r_float_ex( "sim_task_props", "task_weight_mult" ) or 1)
	while ( task_manager.task_ini:section_exist( task_id ) ) do

		-- Check if the current task is a linked task:
		local link_back_info = task_manager.task_ini:r_string_ex( task_id, "link_back_info" )
		if ( ((not linked_task) and (not link_back_info)) or (linked_task and link_back_info and link_back_info == link_info) or (link_back_info and has_alife_info( link_back_info )) ) then

			-- Check task prerequisites:
			if ( (task_info[task_id] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {task_id} )) ) then

				-- If valid linked task then give the task:
				if ( (linked_task and link_back_info and link_back_info == link_info) or (link_back_info and has_alife_info( link_back_info )) ) then
					axr_task_manager.available_tasks[npc_id][1] = task_id
					return true

				-- Otherwise add task to lisk of valid tasks:
				else
					local task_weight = ((task_manager.task_ini:r_float_ex( task_id, "weight" ) or 1) * weight_mult)
					for i = 1, ( task_weight ) do
						table.insert( valid_task_list, task_id )
					end

				end

			end

		end

		-- Format next task for next loop:
		task_number = (task_number + 1)
		task_id = string.format( "%s_%s", task_section_name, task_number )

	end

	-- Pick random task from list:
	local new_task
	if ( #valid_task_list < 1 ) then
		new_task = xr_effects.drx_ql_meet_random_honcho( nil, npc, {true} )
	else
		new_task = valid_task_list[math.random( #valid_task_list )]
	end

	-- Store current available task for current npc:
	axr_task_manager.available_tasks[npc_id][1] = new_task

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_generate_dynamic_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates a dynamic task from important npc's during a dialog
--		- Modification of axr_task_manager.generate_available_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_generate_dynamic_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_npc_stored_task_{npc_id} (type: string, task id)
--			- Stored task the npc has to offer
--		drx_ql_npc_stored_task_time_{npc_id} (type: int, time)
--			- Time the npc stored task was first offered
--		drx_ql_{task_id}_{npc_id}_assassination_target (type: npc id)
--			- Id of selected assassination target for specified task
--		drx_ql_current_npc_speaker_id (type: npc id)
--			- Id of the current npc the actor is speaking to
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[sim_task_props]
--				task_offer_percent (type: float, decimal percent)
--					- Percent chance an NPC will have a new task to offer
--				stored_task_reset_time (type: int, seconds)
--					- Length of time NPC's store the same task before offering a new one
--				task_weight_mult (type: int)
--					- Multiplier to apply to task weights
--		misc\drx_ql_tasks\drx_ql_tasks_*.ltx
--			[{task_id}]
--				weight (type: int)
--					- Higher numbers increase the probability the task will be offered (recommended: 1-3) (optional; default = 1)
--
--	Return value (type: bool):
--		Returns true on success
--		Returns false on failure
--
--	Notes:
--		- Generated task is stored in axr_task_manager.available_tasks[{npc_id}][1]
--		- Dynamic tasks are defined in configs\misc\drx_ql_tasks\drx_ql_tasks_*.ltx
--		- Task section names for dynamic tasks must follow this format: drx_ql_{npc_id}_task_{x}
--			{npc_id} = NPC name as defined in configs\gameplay\character_desc_*.ltx
--			{x} = sequential number starting at 1
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 02, 2019
-- ------------------------------------------------------------------------------------------------

-- Generate dynamic task:
function drx_ql_generate_dynamic_task( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate dynamic task, cannot locate ini file" )
		return false
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate dynamic task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate dynamic task, npc id is invalid" )
		return false
	end
	utils.save_var( db.actor, "drx_ql_current_npc_speaker_id", npc_id )

	-- Remove current available tasks for the npc:
	axr_task_manager.available_tasks[npc_id] = iempty_table( axr_task_manager.available_tasks[npc_id] )

	-- Get current stored task info for current npc:
	local npc_stored_task = utils.load_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), nil )
	local time_last_checked = utils.load_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ) )
	local task_reset_time = (ini:r_float_ex( "sim_task_props", "stored_task_reset_time" ) or 0)
	local task_info = task_manager.get_task_manager( ).task_info

	-- Check if stored task has not timed out:
	if ( (time_last_checked) and (game.get_game_time( ):diffSec( time_last_checked ) < task_reset_time) ) then

		-- If stored task is still valid then re-offer the task, otherwise offer nothing:
		if ( (npc_stored_task) and (task_info[npc_stored_task] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {npc_stored_task} )) ) then
			axr_task_manager.available_tasks[npc_id][1] = npc_stored_task
		end
		return true

	end

	-- Reset stored vars:
	if ( npc_stored_task ) then
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_assassination_target", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_target_smart", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_enemy_smart_name", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_friendly_smart_name", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_enemy_faction", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_friendly_faction", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), nil )
	end

	-- Decide if current npc should have task to give:
	local percent_chance = (ini:r_float_ex( "sim_task_props", "task_offer_percent" ) or 1)
	if ( math.random( ) > percent_chance ) then
		utils.save_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), nil )
		utils.save_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ), game.get_game_time( ) )
		return true
	end

	-- Format task section name:
	local section_name
	local storage = db.storage[npc_id]
	if ( (storage) and (storage.ini) and (storage.section_logic) ) then
		section_name = storage.ini:r_string_ex( storage.section_logic, "task_section" )
		if ( section_name ) then
			section_name = string.format( "drx_ql_%s_task", section_name )
		end
	end
	if not ( section_name ) then
		if ( npc:section( ) == "m_trader" ) then
			section_name = string.format( "drx_ql_%s_task", npc:name( ) )
		else
			section_name = string.format( "drx_ql_%s_task", npc:section( ) )
		end
	end

	-- Generate list of valid tasks:
	local valid_task_list = {}
	local task_number = 1
	local task_id = string.format( "%s_%s", section_name, task_number )
	local weight_mult = (ini:r_float_ex( "sim_task_props", "task_weight_mult" ) or 1)
	while ( task_manager.task_ini:section_exist( task_id ) ) do

		-- Check task prerequisites:
		if ( (task_info[task_id] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {task_id} )) ) then

			-- Adjust task weight for current valid task:
			local task_weight = ((task_manager.task_ini:r_float_ex( task_id, "weight" ) or 1) * weight_mult)
			for i = 1, ( task_weight ) do

				-- Add current task to valid task list:
				table.insert( valid_task_list, task_id )

			end

		end

		-- Format next task for next loop:
		task_number = (task_number + 1)
		task_id = string.format( "%s_%s", section_name, task_number )

	end

	-- Pick random task from list:
	local new_task
	if ( #valid_task_list > 0 ) then
		new_task = valid_task_list[math.random( #valid_task_list )]
	end

	-- Store current available task for current npc:
	axr_task_manager.available_tasks[npc_id][1] = new_task
	utils.save_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), new_task )
	utils.save_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ), game.get_game_time( ) )

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_generate_sim_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates a simulation task from generic npc' during a dialog
--		- Modification of axr_task_manager.generate_available_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_generate_sim_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_npc_stored_task_{npc_id} (type: string, task id)
--			- Stored task the npc has to offer
--		drx_ql_npc_stored_task_time_{npc_id} (type: int, time)
--			- Time the npc stored task was first offered
--		drx_ql_npc_safecracker_eligible_{npc_id} (type: bool)
--			- Flag indicating whether or not the npc is safecracker eligible
--		drx_ql_{task_id}_{npc_id}_assassination_target (type: npc id)
--			- Id of selected assassination target for specified task
--		drx_ql_{task_id}_{npc_id}_target_smart (type: smart terrain id)
--			- Id of selected target smart terrain for specified task
--		drx_ql_{task_id}_{npc_id}_enemy_smart_name (type: smart terrain name)
--			- Name of the stored enemy smart terrain for a brawl task
--		drx_ql_{task_id}_{npc_id}_friendly_smart_name (type: smart terrain name)
--			- Name of the stored friendly smart terrain for a brawl task
--		drx_ql_{task_id}_{npc_id}_enemy_faction (type: faction name)
--			- Name of the stored enemy faction
--		drx_ql_{task_id}_{npc_id}_friendly_faction (type: faction name)
--			- Name of the stored friendly faction
--		drx_ql_current_npc_speaker_id (type: npc id)
--			- Id of the current npc the actor is speaking to
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[sim_task_props]
--				task_offer_percent (type: float, decimal percent)
--					- Percent chance an NPC will have a new task to offer
--				stored_task_reset_time (type: int, seconds)
--					- Length of time NPC's store the same task before offering a new one
--				task_weight_mult (type: int)
--					- Multiplier to apply to task weights
--		misc\tm_dynamic.ltx
--			[{task_id}]
--				sim_communities (type: string, comma-delimited list of faction names)
--					- List of allowable factions to give the task
--				weight (type: int)
--					- Higher numbers increase the probability the task will be offered (recommended: 1-3) (optional; default = 1)
--
--	Return value (type: bool):
--		Returns true on success
--		Returns false on failure
--
--	Notes:
--		- Generated task is stored in axr_task_manager.available_tasks[{npc_id}][1]
--		- Simulation tasks are defined in configs\misc\tm_dynamic.ltx
--		- Task section names for simulation tasks must follow this format: drx_ql_simulation_task_{faction}_{x}
--			[faction} = NPC faction
--			{x} = sequential number starting at 1
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 02, 2019
-- ------------------------------------------------------------------------------------------------

-- Generate simulation task:
function drx_ql_generate_sim_task( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate simulation task, cannot locate ini file" )
		return false
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate simulation task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate simulation task, npc id is invalid" )
		return false
	end
	utils.save_var( db.actor, "drx_ql_current_npc_speaker_id", npc_id )

	-- Remove current available tasks for the npc:
	axr_task_manager.available_tasks[npc_id] = iempty_table( axr_task_manager.available_tasks[npc_id] )

	-- Get current stored task info for current npc:
	local npc_stored_task = utils.load_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), nil )
	local time_last_checked = utils.load_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ) )
	local task_reset_time = (ini:r_float_ex( "sim_task_props", "stored_task_reset_time" ) or 0)
	local task_info = task_manager.get_task_manager( ).task_info

	-- Check if stored task has not timed out:
	if ( (time_last_checked) and (game.get_game_time( ):diffSec( time_last_checked ) < task_reset_time) ) then

		-- If stored task is still valid then re-offer the task, otherwise offer nothing:
		if ( (npc_stored_task) and (task_info[npc_stored_task] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {npc_stored_task} )) ) then
			axr_task_manager.available_tasks[npc_id][1] = npc_stored_task
		end
		return true

	end

	-- Reset stored vars:
	if ( npc_stored_task ) then
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_assassination_target", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_target_smart", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_enemy_smart_name", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_friendly_smart_name", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_enemy_faction", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_%s_%s_friendly_faction", npc_stored_task, npc_id ), nil )
		utils.save_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), nil )
	end
	utils.save_var( db.actor, string.format( "drx_ql_npc_safecracker_eligible_%s", npc_id ), nil )

	-- Decide if current npc should have task to give:
	local percent_chance = (ini:r_float_ex( "sim_task_props", "task_offer_percent" ) or 1)
	if ( math.random( ) > percent_chance ) then
		utils.save_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), nil )
		utils.save_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ), game.get_game_time( ) )
		return true
	end

	-- Format task section name:
	local section_name
	local storage = db.storage[npc_id]
	if ( (storage) and (storage.ini) and (storage.section_logic) ) then
		section_name = storage.ini:r_string_ex( storage.section_logic, "task_section" )
		if ( section_name ) then
			section_name = string.format( "drx_ql_%s_task_", section_name )
		end
	end
	if not ( section_name ) then
		section_name = string.format( "drx_ql_simulation_task_%s_", character_community( npc ) )
	end

	-- Generate list of valid tasks:
	local valid_task_list = {}
	local task_number = 1
	local task_id = string.format( "%s%s", section_name, task_number )
	local weight_mult = (ini:r_float_ex( "sim_task_props", "task_weight_mult" ) or 1)
	while ( task_manager.task_ini:section_exist( task_id ) ) do

		-- Check task prerequisites:
		if ( (task_info[task_id] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {task_id} )) ) then

			-- Adjust task weight for current valid task:
			local task_weight = ((task_manager.task_ini:r_float_ex( task_id, "weight" ) or 1) * weight_mult)
			for i = 1, ( task_weight ) do

				-- Add current task to valid task list:
				table.insert( valid_task_list, task_id )

			end

		end

		-- Format next task for next loop:
		task_number = (task_number + 1)
		task_id = string.format( "%s%s", section_name, task_number )

	end

	-- Pick random task from list:
	local new_task
	if ( #valid_task_list > 0 ) then
		new_task = valid_task_list[math.random( #valid_task_list )]
	end

	-- Store current available task for current npc:
	axr_task_manager.available_tasks[npc_id][1] = new_task
	utils.save_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), new_task )
	utils.save_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ), game.get_game_time( ) )

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_generate_mechanic_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates a mechanic task during a dialog
--		- Modification of axr_task_manager.generate_available_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_generate_mechanic_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_current_npc_speaker_id (type: npc id)
--			- Id of the current npc the actor is speaking to
--		drx_ql_npc_stored_task_{npc_id} (type: string, task id)
--			- Stored task the npc has to offer
--		drx_ql_npc_stored_task_time_{npc_id} (type: int, time)
--			- Time the npc stored task was first offered
--		drx_ql_last_upgrade_time_{npc_name} (type: int, time)
--			- Time the mechanic was last upgraded
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[sim_task_props]
--				stored_task_reset_time (type: int, seconds)
--					- Length of time NPC's store the same task before offering a new one
--				min_upgrade_time (type: int, seconds)
--					- Minimum time between mechanic upgrade tasks
--				task_weight_mult (type: int)
--					- Multiplier to apply to task weights
--		misc\drx_ql_tasks\drx_ql_tasks_*.ltx
--			[{task_id}]
--				weight (type: int)
--					- Higher numbers increase the probability the task will be offered (recommended: 1-3) (optional; default = 1)
--
--	Return value (type: bool):
--		Returns true on success
--		Returns false on failure
--
--	Notes:
--		- Generated task is stored in axr_task_manager.available_tasks[{npc_id}][1]
--		- Mechanic tasks are defined in configs\misc\drx_ql_tasks\drx_ql_tasks_*.ltx
--		- Task section names for mechanic tasks must follow this format: drx_ql_task_{npc_id}_task_{x}
--			{npc_id} = NPC name as defined in configs\gameplay\character_desc_*.ltx
--			{x} = sequential number starting at 1
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 02, 2019
-- ------------------------------------------------------------------------------------------------

-- Generate mechanic task:
function drx_ql_generate_mechanic_task( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate mechanic task, cannot locate ini file" )
		return false
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate mechanic task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate mechanic task, npc id is invalid" )
		return false
	end
	utils.save_var( db.actor, "drx_ql_current_npc_speaker_id", npc_id )

	-- Remove current available tasks for the npc:
	axr_task_manager.available_tasks[npc_id] = iempty_table( axr_task_manager.available_tasks[npc_id] )

	-- Get current stored task info for current npc:
	local npc_stored_task = utils.load_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), nil )
	local time_last_checked = utils.load_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ) )
	local task_reset_time = (ini:r_float_ex( "sim_task_props", "stored_task_reset_time" ) or 0)
	local task_info = task_manager.get_task_manager( ).task_info

	-- Check if stored task has not timed out:
	if ( (time_last_checked) and (game.get_game_time( ):diffSec( time_last_checked ) < task_reset_time) ) then

		-- If stored task is still valid then re-offer the task, otherwise offer nothing:
		if ( (npc_stored_task) and (task_info[npc_stored_task] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {npc_stored_task} )) ) then
			axr_task_manager.available_tasks[npc_id][1] = npc_stored_task
		end
		return true

	end

	-- Get npc name:
	local npc_name = npc:section( )
	if ( npc_name == "m_trader" ) then
		npc_name = npc:name( )
	end

	-- Check if minimum upgrade time has elapsed:
	local min_upgrade_time = (ini:r_float_ex( "sim_task_props", "min_upgrade_time" ) or 0)
	local last_upgrade_time = utils.load_ctime( db.actor, string.format( "drx_ql_last_upgrade_time_%s", npc_name ) )
	if ( (last_upgrade_time) and (game.get_game_time( ):diffSec( last_upgrade_time ) < min_upgrade_time) ) then
		return true
	end

	-- Format task section name:
	local section_name
	local storage = db.storage[npc_id]
	if ( (storage) and (storage.ini) and (storage.section_logic) ) then
		section_name = storage.ini:r_string_ex( storage.section_logic, "task_section" )
		if ( section_name ) then
			section_name = string.format( "drx_ql_%s_task_", section_name )
		end
	end
	if not ( section_name ) then
		section_name = string.format( "drx_ql_%s_task_", npc_name )
	end

	-- Generate list of valid tasks:
	local task_info = task_manager.get_task_manager( ).task_info
	local valid_task_list = {}
	local task_number = 1
	local task_id = string.format( "%s%s", section_name, task_number )
	local weight_mult = (ini:r_float_ex( "sim_task_props", "task_weight_mult" ) or 1)
	while ( task_manager.task_ini:section_exist( task_id ) ) do

		-- Check task prerequisites:
		if ( (task_info[task_id] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {task_id} )) ) then

			-- Adjust task weight for current valid task:
			local task_weight = ((task_manager.task_ini:r_float_ex( task_id, "weight" ) or 1) * weight_mult)
			for i = 1, ( task_weight ) do

				-- Add current task to valid task list:
				table.insert( valid_task_list, task_id )

			end

		end

		-- Format next task for next loop:
		task_number = (task_number + 1)
		task_id = string.format( "%s%s", section_name, task_number )

	end

	-- Pick random task from list:
	local new_task
	if ( #valid_task_list > 0 ) then
		new_task = valid_task_list[math.random( #valid_task_list )]
	end

	-- Store current available task for current npc:
	axr_task_manager.available_tasks[npc_id][1] = new_task
	utils.save_var( db.actor, string.format( "drx_ql_npc_stored_task_%s", npc_id ), new_task )
	utils.save_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ), game.get_game_time( ) )

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_generate_cf_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates a change faction task during a dialog
--		- Modification of axr_task_manager.generate_available_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_generate_cf_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true on success
--		Returns false on failure
--
--	Notes:
--		- Generated task is stored in axr_task_manager.available_tasks[{npc_id}][1]
--		- Tasks are defined in configs\misc\tm_*.ltx
--		- Task section names for change faction tasks must follow this format: drx_ql_{npc_name}_cf_task_{x}
--			{npc_name} = npc section name (ie; bar_dolg_general_petrenko_stalker, esc_m_trader)
--			{x} = sequential number starting at 1
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified September 28, 2017
-- ------------------------------------------------------------------------------------------------

-- Generate change faction task:
function drx_ql_generate_cf_task( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate change faction task, npc id is invalid" )
		return false
	end

	-- Remove current available tasks for the npc:
	axr_task_manager.available_tasks[npc_id] = iempty_table( axr_task_manager.available_tasks[npc_id] )

	-- Format task section name:
	local section_name
	local storage = db.storage[npc_id]
	if ( (storage) and (storage.ini) and (storage.section_logic) ) then
		section_name = storage.ini:r_string_ex( storage.section_logic, "task_section" )
		if ( section_name ) then
			section_name = string.format( "drx_ql_%s_cf_task_", section_name )
		end
	end
	if not ( section_name ) then
		if ( npc:section( ) == "m_trader" ) then
			section_name = string.format( "drx_ql_%s_cf_task_", npc:name( ) )
		else
			section_name = string.format( "drx_ql_%s_cf_task_", npc:section( ) )
		end
	end

	-- Generate list of valid tasks:
	local task_info = task_manager.get_task_manager( ).task_info
	local valid_task_list = {}
	local task_number = 1
	local task_id = string.format( "%s%s", section_name, task_number )
	while ( task_manager.task_ini:section_exist( task_id ) ) do
		if ( (task_info[task_id] == nil) and (xr_conditions.has_completed_task_prerequisites( nil, nil, {task_id} )) ) then
			table.insert( valid_task_list, task_id )
		end
		task_number = (task_number + 1)
		task_id = string.format( "%s%s", section_name, task_number )
	end

	-- Pick random task from list of valid tasks and store in available tasks:
	if ( #valid_task_list > 0 ) then
		axr_task_manager.available_tasks[npc_id][1] = valid_task_list[math.random( #valid_task_list )]
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- COMPLETE TASK FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_set_start_game_task_complete function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Sets the starting game task to complete
--
--	Usage:
--		drx_ql_set_start_game_task_complete( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 08, 2017
-- ------------------------------------------------------------------------------------------------

-- Set starting game task to complete:
function drx_ql_set_start_game_task_complete( speaker_1, speaker_2 )

	-- Get npc name:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_name = npc:section( )
	if ( not npc_name ) then
		printf( "DRX QL Error: Unable to set start game task to complete, npc name is invalid" )
		return false
	end
	if ( npc:section( ) == "m_trader" ) then
		npc_name = npc:name( )
	end

	-- Set start game task to complete:
	disable_info( string.format( "drx_ql_start_game_%s", npc_name ) )
	printf( "DRX QL: Start game task drx_ql_start_game_%s completed", npc_name )

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_set_sl_task_complete function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Sets a finished storyline task to complete
--		- Modification of dialogs.npc_set_finished_task_complete (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_set_sl_task_complete( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
--	Notes:
--		- Completed storyline tasks are stored in drx_ql_completed_sl_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 17, 2017
-- ------------------------------------------------------------------------------------------------

-- Set the finished storyline task to complete:
function drx_ql_set_sl_task_complete( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to set storyline task to complete, npc id is invalid" )
		return
	end

	-- Check if a completed sl task exists:
	if ( (not drx_ql_completed_sl_tasks) or (not drx_ql_completed_sl_tasks[npc_id]) or (not drx_ql_completed_sl_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to set storyline task to complete, no finished sl tasks found" )
		return
	end

	-- Set sl task to complete:
	task_manager.get_task_manager( ):set_task_completed( drx_ql_completed_sl_tasks[npc_id][1] )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_sl_task_finished_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines dialog text to display at the end of a storyline task
--		- Modification of dialogs.text_npc_task_finish (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_sl_task_finished_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\tm_*.ltx
--			[{task_id}]
--				task_complete_descr (type: string, string id)
--					- Id of the string to display when a cf task is finished
--
--	External strings:
--		st_dialog_manager.xml
--			st_default_task_finished_{x} (type: string)
--				- Default task finished text string ({x} = sequential int starting at 1)
--
--	Return value (type: string):
--		Returns the text for the dialog speaker to display
--		Returns nil on failure
--
--	Notes:
--		- Completed storyline tasks are stored in drx_ql_completed_sl_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 17, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine the text to display at the end of a storyline task:
function drx_ql_sl_task_finished_text( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate finished sl task text, npc id is invalid" )
		return
	end

	-- Check if a completed sl task exists:
	if ( (not drx_ql_completed_sl_tasks) or (not drx_ql_completed_sl_tasks[npc_id]) or (not drx_ql_completed_sl_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to generate finished sl task text, no finished sl tasks found" )
		return
	end

	-- Get the task id of the completed sl task:
	local task_id = drx_ql_completed_sl_tasks[npc_id][1]

	-- Generate the sl task finished text:
	local retstring = game.translate_string( (task_id and task_manager.task_ini:r_string_ex( task_id, "task_complete_descr" )) or (drx_ql_random_phrase( "st_default_task_finished" )) )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_generate_endgame_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates the first task for the endgame questline
--
--	Usage:
--		drx_ql_generate_endgame_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_current_honcho (type: string, npc name)
--			Current meet honcho target npc
--		drx_ql_current_task (type: string, task id)
--			ID of the current questline task the player has
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[end_game_task]
--				meet_honcho (type: string, npc id)
--					- Honcho to meet to start the endgame questline
--				task_id (type: string, task id)
--					- Endgame questline start task id
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified May 08, 2019
-- ------------------------------------------------------------------------------------------------

-- Generate first task on endgame questline:
function drx_ql_generate_endgame_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Could not generate first task for endgame questline, db.actor not available" )
		return
	end

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Could not generate first task for endgame questline, cannot locate ini file" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate first task for endgame questline, npc id is invalid" )
		return
	end

	-- Get meet honcho id for start endgame questline task:
	local next_honcho = ini:r_string_ex( "end_game_task", "meet_honcho" )
	if ( not next_honcho ) then
		printf( "DRX QL Error: Unable to generate first task for endgame questline, no meet honcho specified" )
		return
	end

	-- Get task id start endgame questline task:
	local meet_task = ini:r_string_ex( "end_game_task", "task_id" )
	if ( not meet_task ) then
		printf( "DRX QL Error: Unable to generate first task for endgame questline, no task specified" )
		return
	end

	-- Remove previously generated meet random honcho task:
	disable_info( string.format( "drx_ql_meet_honcho_%s", utils.load_var( db.actor, "drx_ql_current_honcho", "" ) ) )

	-- Set up meet endgame honcho task:
	utils.save_var( db.actor, "drx_ql_current_honcho", next_honcho )
	utils.save_var( db.actor, "drx_ql_current_task", meet_task )
	printf( "DRX QL: Current storyline task is %s", meet_task )
	give_info( string.format( "drx_ql_meet_honcho_%s", next_honcho ) )
	axr_task_manager.available_tasks[npc_id][1] = meet_task

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_set_cf_task_complete function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Sets a finished change factions task to complete
--		- Modification of dialogs.npc_set_finished_task_complete (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_set_cf_task_complete( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
--	Notes:
--		- Completed change factions tasks are stored in drx_ql_completed_cf_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 04, 2017
-- ------------------------------------------------------------------------------------------------

-- Set the finished change factions task to complete:
function drx_ql_set_cf_task_complete( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to set change factions task to complete, npc id is invalid" )
		return
	end

	-- Check if a completed cf task exists:
	if ( (not drx_ql_completed_cf_tasks) or (not drx_ql_completed_cf_tasks[npc_id]) or (not drx_ql_completed_cf_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to set change factions task to complete, no finished cf tasks found" )
		return
	end

	-- Set cf task to complete:
	task_manager.get_task_manager( ):set_task_completed( drx_ql_completed_cf_tasks[npc_id][1] )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_cf_task_finished_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines dialog text to display at the end of a change factions task
--		- Modification of dialogs.text_npc_task_finish (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_cf_task_finished_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\tm_*.ltx
--			[{task_id}]
--				task_complete_descr (type: string, string id)
--					- Id of the string to display when a cf task is finished
--
--	External strings:
--		st_dialog_manager.xml
--			st_default_task_finished_{x} (type: string)
--				- Default task finished text string ({x} = sequential int starting at 1)
--
--	Return value (type: string):
--		Returns the text for the dialog speaker to display
--		Returns nil on failure
--
--	Notes:
--		- Completed change factions tasks are stored in drx_ql_completed_cf_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 17, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine the text to display at the end of a change factions task:
function drx_ql_cf_task_finished_text( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate finished cf task text, npc id is invalid" )
		return
	end

	-- Check if a completed cf task exists:
	if ( (not drx_ql_completed_cf_tasks) or (not drx_ql_completed_cf_tasks[npc_id]) or (not drx_ql_completed_cf_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to generate finished cf task text, no finished cf tasks found" )
		return
	end

	-- Get the task id of the completed cf task:
	local task_id = drx_ql_completed_cf_tasks[npc_id][1]

	-- Generate the cf task finished text:
	local retstring = game.translate_string( (task_id and task_manager.task_ini:r_string_ex( task_id, "task_complete_descr" )) or (drx_ql_random_phrase( "st_default_task_finished" )) )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- CANCEL TASK FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_task_cancel_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines dialog text to display when confirming a task cancellation
--		- Modification of dialogs.text_npc_has_cancel_task (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_task_cancel_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\tm_*.ltx
--			[{task_id}]
--				fetch_descr (type: string, string id)
--					- Id of the string to display of the fetch item to get (optional; only required for fetch quests)
--				title (type: string, string id)
--					- Id of the string to display as the title for a task
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_task_cancel
--				- Text to display when NPC asks for confirmation of task to cancel
--		st_dialog_manager.xml
--			st_task_none_active (type: string)
--				- Text to display when an NPC has no active tasks to cancel
--
--	Return value (type: string):
--		Returns the text for the dialog speaker to display
--		Returns nil on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 15, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine the text to display when confirming task cancellation:
function drx_ql_task_cancel_text( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate cancel task text, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate cancel task text, npc id is invalid" )
		return
	end

	-- Ensure a currently active task exists:
	if ( (not axr_task_manager.ongoing_tasks[npc_id]) or (not axr_task_manager.ongoing_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to generate cancel task text, no active tasks found" )
		return
	end

	-- Get the task id of the current task:
	local task_id = axr_task_manager.ongoing_tasks[npc_id][1]
	if ( not task_id ) then
		return game.translate_string( "st_task_none_active" )
	end

	-- Get the task title:
	local task_title = game.translate_string( task_manager.task_ini:r_string_ex( task_id, "title" ) )

	-- Add in fetch item text:
	if ( task_manager.task_ini:r_string_ex( task_id, "fetch_descr" ) ) then
        local fetch_section = utils.load_var( db.actor, string.format( "%s_fetch", task_id ) )
        if ( fetch_section ) then
			local fetch_item = game.translate_string( (system_ini( ):r_string_ex( fetch_section, "inv_name" ) or "") )
			task_title = string.format( task_title, fetch_item )
		end
	end

	-- Generate cancel task text:
	local retstring = string.format( game.translate_string( "drx_ql_str_task_cancel" ), task_title )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_cancel_sl_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Cancels a storyline task
--		- Modification of dialogs.npc_cancel_task (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_cancel_sl_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
--	Notes:
--		- Current storyline tasks are stored in drx_ql_current_sl_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 17, 2017
-- ------------------------------------------------------------------------------------------------

-- Cancel the current storyline task:
function drx_ql_cancel_sl_task( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to cancel sl task, npc id is invalid" )
		return
	end

	-- Check if a current sl task exists:
	if ( (not drx_ql_current_sl_tasks) or (not drx_ql_current_sl_tasks[npc_id]) or (not drx_ql_current_sl_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to cancel sl task, no current sl tasks found" )
		return
	end

	-- Cancel the current sl task:
	task_manager.get_task_manager( ):set_task_cancelled( drx_ql_current_sl_tasks[npc_id][1] )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_sl_task_cancel_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines dialog text to display when confirming a storyline task cancellation
--		- Modification of dialogs.text_npc_has_cancel_task (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_sl_task_cancel_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\tm_*.ltx
--			[{task_id}]
--				fetch_descr (type: string, string id)
--					- Id of the string to display of the fetch item to get (optional; only required for fetch quests)
--				title (type: string, string id)
--					- Id of the string to display as the title for a task
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_task_cancel
--				- Text to display when NPC asks for confirmation of task to cancel
--		st_dialog_manager.xml
--			st_task_none_active (type: string)
--				- Text to display when an NPC has no active tasks to cancel
--
--	Return value (type: string):
--		Returns the text for the dialog speaker to display
--		Returns nil on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 17, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine the text to display when confirming storyline task cancellation:
function drx_ql_sl_task_cancel_text( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate cancel storyline task text, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate cancel storyline task text, npc id is invalid" )
		return
	end

	-- Ensure a currently active storyline task exists:
	if ( (not drx_ql_current_sl_tasks[npc_id]) or (not drx_ql_current_sl_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to generate cancel storyline task text, no active tasks found" )
		return
	end

	-- Get the task id of the current task:
	local task_id = drx_ql_current_sl_tasks[npc_id][1]
	if ( not task_id ) then
		return game.translate_string( "st_task_none_active" )
	end

	-- Get the task title:
	local task_title = game.translate_string( task_manager.task_ini:r_string_ex( task_id, "title" ) )

	-- Add in fetch item text:
	if ( task_manager.task_ini:r_string_ex( task_id, "fetch_descr" ) ) then
        local fetch_section = utils.load_var( db.actor, string.format( "%s_fetch", task_id ) )
        if ( fetch_section ) then
			local fetch_item = game.translate_string( (system_ini( ):r_string_ex( fetch_section, "inv_name" ) or "") )
			task_title = string.format( task_title, fetch_item )
		end
	end

	-- Generate cancel task text:
	local retstring = string.format( game.translate_string( "drx_ql_str_task_cancel" ), task_title )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_cf_task_cancel_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines dialog text to display at the end of a change factions task cancellation
--
--	Usage:
--		drx_ql_cf_task_cancel_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_cf_task_cancel_accepted (type: string)
--				- Text to display when an NPC accepts that the player wants to cancel a cf task
--
--	Return value (type: string):
--		Returns the text for the dialog speaker to display
--		Returns nil on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 04, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine the text to display at the end of a change factions task cancellation:
function drx_ql_cf_task_cancel_text( speaker_1, speaker_2 )

	-- Generate the cf task cancelled text:
	local retstring = game.translate_string( "drx_ql_str_cf_task_cancel_accepted" )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_cancel_cf_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Cancels a change factions task
--		- Modification of dialogs.npc_cancel_task (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_cancel_cf_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
--	Notes:
--		- Current change factions tasks are stored in drx_ql_current_cf_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 04, 2017
-- ------------------------------------------------------------------------------------------------

-- Cancel the current change factions task:
function drx_ql_cancel_cf_task( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to cancel cf task, npc id is invalid" )
		return
	end

	-- Check if a current cf task exists:
	if ( (not drx_ql_current_cf_tasks) or (not drx_ql_current_cf_tasks[npc_id]) or (not drx_ql_current_cf_tasks[npc_id][1]) ) then
		printf( "DRX QL Error: Unable to cancel cf task, no current cf tasks found" )
		return
	end

	-- Cancel the current cf task:
	task_manager.get_task_manager( ):set_task_cancelled( drx_ql_current_cf_tasks[npc_id][1] )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- HAS COMPLETED TASK FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_finished_sl_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a completed storyline task
--		- Modification of axr_task_manager.generate_finished_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_finished_sl_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\tm_*.ltx
--			[{task_id}]
--				stage_complete (type: int)
--					- Number of stages to complete to finish the task
--
--	Return value (type: bool):
--		Returns true if the player has a completed storyline task, false otherwise
--
--	Notes:
--		- If a completed storyline task is found, its id will be stored in drx_ql_completed_sl_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified January 28, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has completed storyline task:
function drx_ql_actor_has_finished_sl_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has completed storyline task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has completed storyline task, npc id is invalid" )
		return false
	end

	-- Clear finished sl tasks table:
	drx_ql_completed_sl_tasks[npc_id] = iempty_table( drx_ql_completed_sl_tasks[npc_id] )

	-- Get npc faction:
	local npc_faction = drx_ql_npc_faction( npc )

	-- Format task section name:
	local section_name = string.format( "drx_ql_%s_sl_task", npc_faction )

	-- Check for a completed storyline task:
	local task_number = 1
	local task_info = task_manager.get_task_manager( ).task_info
	local task_id = string.format( "%s_%s", section_name, task_number )
	while ( task_manager.task_ini:section_exist( task_id ) ) do
		if ( (db.actor:get_task( task_id, true ) ~= nil) and (task_info[task_id]) ) then
			if ( (task_info[task_id].task_giver_id) and (task_info[task_id].task_giver_id == npc_id) ) then
				if ( (task_info[task_id].stage ~= nil) and (task_info[task_id].stage == (task_manager.task_ini:r_float_ex( task_id, "stage_complete" ) or 255)) ) then
					if ( (task_info[task_id].status ~= "fail") and (task_info[task_id].status ~= "completed") ) then
						drx_ql_completed_sl_tasks[npc_id][1] = task_id
						return true
					end
				end
			end
		end
		task_number = (task_number + 1)
		task_id = string.format( "%s_%s", section_name, task_number )
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_finished_dyn_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a completed dynamic task
--		- Modification of dialogs.actor_has_finished_task / axr_task_manager.generate_finished_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_finished_dyn_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\drx_ql_tasks\dtx_ql_tasks_*.ltx
--			[{task_id}]
--				stage_complete (type: int)
--					- Number of stages to complete to finish the task
--
--	Return value (type: bool):
--		Returns true if the player has a completed dynamic task, false otherwise
--
--	Notes:
--		- If a completed dynamic task is found, its id will be stored in axr_task_manager.finished_tasks[npc:id( )][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified January 28, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has completed dynamic task:
function drx_ql_actor_has_finished_dyn_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has completed dynamic task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has completed dynamic task, npc id is invalid" )
		return false
	end

	-- Get npc name:
	local npc_name
	if ( npc:section( ) == "m_trader" ) then
		npc_name = npc:name( )
	else
		npc_name = npc:section( )
	end

	-- Clear finished tasks table:
	axr_task_manager.finished_tasks[npc_id] = iempty_table( axr_task_manager.finished_tasks[npc_id] )

	-- Format task section name:
	local section_name = string.format( "drx_ql_%s_task", npc_name )

	-- Check for a completed dynamic task:
	local task_number = 1
	local task_info = task_manager.get_task_manager( ).task_info
	local task_id = string.format( "%s_%s", section_name, task_number )
	while ( task_manager.task_ini:section_exist( task_id ) ) do
		if ( (db.actor:get_task( task_id, true ) ~= nil) and (task_info[task_id]) ) then
			if ( (task_info[task_id].task_giver_id) and (task_info[task_id].task_giver_id == npc_id) ) then
				if ( (task_info[task_id].stage ~= nil) and (task_info[task_id].stage == (task_manager.task_ini:r_float_ex( task_id, "stage_complete" ) or 255)) ) then
					if ( (task_info[task_id].status ~= "fail") and (task_info[task_id].status ~= "completed") ) then
						axr_task_manager.finished_tasks[npc_id][1] = task_id
						return true
					end
				end
			end
		end
		task_number = (task_number + 1)
		task_id = string.format( "%s_%s", section_name, task_number )
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_finished_sim_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a completed simulation task
--		- Modification of dialogs.actor_has_finished_task / axr_task_manager.generate_finished_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_finished_sim_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\drx_ql_tasks\dtx_ql_tasks_*.ltx
--			[{task_id}]
--				stage_complete (type: int)
--					- Number of stages to complete to finish the task
--
--	Return value (type: bool):
--		Returns true if the player has a completed simulation task, false otherwise
--
--	Notes:
--		- If a completed simulation task is found, its id will be stored in axr_task_manager.finished_tasks[npc:id( )][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 27, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has completed simulation task:
function drx_ql_actor_has_finished_sim_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has completed simulation task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has completed simulation task, npc id is invalid" )
		return false
	end

	-- Clear finished tasks table:
	axr_task_manager.finished_tasks[npc_id] = iempty_table( axr_task_manager.finished_tasks[npc_id] )

	-- Check for a completed simulation task:
	local task_info = task_manager.get_task_manager( ).task_info
	for task_id, tsk in pairs( task_info ) do
		if ( tsk and (tsk.stage ~= nil) and (tsk.stage == (task_manager.task_ini:r_float_ex( task_id, "stage_complete" ) or 255)) ) then
			if ( tsk.task_giver_id ) then
				if ( npc:id( ) == tsk.task_giver_id ) then
					axr_task_manager.finished_tasks[npc_id][1] = task_id
					return true
				end
			end
		end
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_finished_cf_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a completed change factions task
--		- Modification of axr_task_manager.generate_finished_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_finished_cf_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		misc\tm_*.ltx
--			[{task_id}]
--				stage_complete (type: int)
--					- Number of stages to complete to finish the task
--
--	Return value (type: bool):
--		Returns true if the player has a completed change factions task, false otherwise
--
--	Notes:
--		- If a completed change factions task is found, its id will be stored in drx_ql_completed_cf_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 02, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has completed change factions task:
function drx_ql_actor_has_finished_cf_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has completed change faction task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has completed change faction task, npc id is invalid" )
		return false
	end

	-- Clear finished cf tasks table:
	drx_ql_completed_cf_tasks[npc_id] = iempty_table( drx_ql_completed_cf_tasks[npc_id] )

	-- Format task section name:
	local section_name
	local storage = db.storage[npc_id]
	if ( (storage) and (storage.ini) and (storage.section_logic) ) then
		section_name = storage.ini:r_string_ex( storage.section_logic, "task_section" )
		if ( section_name ) then
			section_name = string.format( "drx_ql_%s_cf_task_", section_name )
		end
	end
	if not ( section_name ) then
		if ( npc:section( ) == "m_trader" ) then
			section_name = string.format( "drx_ql_%s_cf_task_", npc:name( ) )
		else
			section_name = string.format( "drx_ql_%s_cf_task_", npc:section( ) )
		end
	end

	-- Check for a completed change factions task:
	local task_number = 1
	local task_info = task_manager.get_task_manager( ).task_info
	local task_id = string.format( "%s%s", section_name, task_number )
	while ( task_manager.task_ini:section_exist( task_id ) ) do
		if ( (db.actor:get_task( task_id, true ) ~= nil) and (task_info[task_id]) and (task_info[task_id].stage ~= nil) and (task_info[task_id].stage == (task_manager.task_ini:r_float_ex( task_id, "stage_complete" ) or 255)) ) then
			if ( (task_info[task_id].status ~= "fail") and (task_info[task_id].status ~= "completed") ) then
				drx_ql_completed_cf_tasks[npc_id][1] = task_id
				return true
			end
		end
		task_number = (task_number + 1)
		task_id = string.format( "%s%s", section_name, task_number )
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- HAS CURRENT TASK FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_current_sl_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a current storyline task
--		- Modification of dialogs.actor_has_ongoing_task / axr_task_manager.generate_ongoing_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_current_sl_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the player has a current storyline task, false otherwise
--
--	Notes:
--		- If a current storyline task is found, its id will be stored in drx_ql_current_sl_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified January 28, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has current storyline task:
function drx_ql_actor_has_current_sl_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has current storyline task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has storyline faction task, npc id is invalid" )
		return false
	end

	-- Clear ongoing sl tasks table:
	drx_ql_current_sl_tasks[npc_id] = iempty_table( drx_ql_current_sl_tasks[npc_id] )

	-- Get npc faction:
	local npc_faction = drx_ql_npc_faction( npc )

	-- Format task section name:
	local section_name = string.format( "drx_ql_%s_sl_task", npc_faction )

	-- Check for a current storyline task:
	local task_number = 1
	local task_info = task_manager.get_task_manager( ).task_info
	local task_id = string.format( "%s_%s", section_name, task_number )
	while ( task_manager.task_ini:section_exist( task_id ) ) do
		local task_can_be_cancelled = task_manager.task_ini:r_bool_ex( task_id, "can_cancel", true )
		if ( (task_can_be_cancelled == nil) or (task_can_be_cancelled == true) ) then
			if ( (db.actor:get_task( task_id, true )) and (task_info[task_id]) ) then
				if ( (task_info[task_id].task_giver_id) and (task_info[task_id].task_giver_id == npc_id) ) then
					if ( (task_info[task_id].stage) and (task_info[task_id].stage < ((task_manager.task_ini:r_float_ex( task_id, "stage_complete" )) or (255))) ) then
						if ( (task_info[task_id].status ~= "fail") and (task_info[task_id].status ~= "completed") ) then
							drx_ql_current_sl_tasks[npc_id][1] = task_id
							return true
						end
					end
				end
			end
		end
		task_number = (task_number + 1)
		task_id = string.format( "%s_%s", section_name, task_number )
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_current_dyn_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a current dynamic task
--		- Modification of dialogs.actor_has_ongoing_task / axr_task_manager.generate_ongoing_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_current_dyn_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the player has a current dynamic task, false otherwise
--
--	Notes:
--		- If a current dynamic task is found, its id will be stored in axr_task_manager.ongoing_tasks[npc:id( )][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified January 28, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has current dynamic task:
function drx_ql_actor_has_current_dyn_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has current dynamic task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has current dynamic task, npc id is invalid" )
		return false
	end

	-- Clear ongoing tasks table:
	axr_task_manager.ongoing_tasks[npc_id] = iempty_table( axr_task_manager.ongoing_tasks[npc_id] )

	-- Get npc name:
	local npc_name
	if ( npc:section( ) == "m_trader" ) then
		npc_name = npc:name( )
	else
		npc_name = npc:section( )
	end

	-- Format task section name:
	local section_name = string.format( "drx_ql_%s_task", npc_name )

	-- Check for a current dynamic task:
	local task_number = 1
	local task_info = task_manager.get_task_manager( ).task_info
	local task_id = string.format( "%s_%s", section_name, task_number )
	while ( task_manager.task_ini:section_exist( task_id ) ) do
		local task_can_be_cancelled = task_manager.task_ini:r_bool_ex( task_id, "can_cancel", true )
		if ( (task_can_be_cancelled == nil) or (task_can_be_cancelled == true) ) then
			if ( (db.actor:get_task( task_id, true )) and (task_info[task_id]) ) then
				if ( (task_info[task_id].task_giver_id) and (task_info[task_id].task_giver_id == npc_id) ) then
					if ( (task_info[task_id].stage) and (task_info[task_id].stage < ((task_manager.task_ini:r_float_ex( task_id, "stage_complete" )) or (255))) ) then
						if ( (task_info[task_id].status ~= "fail") and (task_info[task_id].status ~= "completed") ) then
							axr_task_manager.ongoing_tasks[npc_id][1] = task_id
							return true
						end
					end
				end
			end
		end
		task_number = (task_number + 1)
		task_id = string.format( "%s_%s", section_name, task_number )
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_current_sim_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a current simulation task
--		- Modification of dialogs.actor_has_ongoing_task / axr_task_manager.generate_ongoing_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_current_sim_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the player has a current simulation task, false otherwise
--
--	Notes:
--		- If a current simulation task is found, its id will be stored in axr_task_manager.ongoing_tasks[npc:id( )][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 27, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has current simulation task:
function drx_ql_actor_has_current_sim_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has current simulation task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has current simulation task, npc id is invalid" )
		return false
	end

	-- Clear ongoing tasks table:
	axr_task_manager.ongoing_tasks[npc_id] = iempty_table( axr_task_manager.ongoing_tasks[npc_id] )

	-- Check for a current simulation task:
	local task_info = task_manager.get_task_manager( ).task_info
	for task_id, tsk in pairs( task_info ) do
		local task_can_be_cancelled = task_manager.task_ini:r_bool_ex( task_id, "can_cancel", true )
		if ( (task_can_be_cancelled == nil) or (task_can_be_cancelled == true) ) then
			if ( tsk and (tsk.stage ~= nil) and (tsk.stage < (task_manager.task_ini:r_float_ex( task_id, "stage_complete" ) or 255)) ) then
				if ( tsk.task_giver_id ) then
					if ( npc:id( ) == tsk.task_giver_id ) then
						axr_task_manager.ongoing_tasks[npc_id][1] = task_id
						return true
					end
				end
			end
		end
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_has_current_cf_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has a current change factions task
--		- Modification of dialogs.actor_has_ongoing_task / axr_task_manager.generate_ongoing_tasks (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_actor_has_current_cf_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the player has a current change factions task, false otherwise
--
--	Notes:
--		- If a current change factions task is found, its id will be stored in drx_ql_current_cf_tasks[{npc_id}][1]
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 04, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has current change factions task:
function drx_ql_actor_has_current_cf_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has current change faction task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if actor has current change faction task, npc id is invalid" )
		return false
	end

	-- Clear ongoing cf tasks table:
	drx_ql_current_cf_tasks[npc_id] = iempty_table( drx_ql_current_cf_tasks[npc_id] )

	-- Format task section name:
	local section_name
	local storage = db.storage[npc_id]
	if ( (storage) and (storage.ini) and (storage.section_logic) ) then
		section_name = storage.ini:r_string_ex( storage.section_logic, "task_section" )
		if ( section_name ) then
			section_name = string.format( "drx_ql_%s_cf_task_", section_name )
		end
	end
	if not ( section_name ) then
		if ( npc:section( ) == "m_trader" ) then
			section_name = string.format( "drx_ql_%s_cf_task_", npc:name( ) )
		else
			section_name = string.format( "drx_ql_%s_cf_task_", npc:section( ) )
		end
	end

	-- Check for a current change factions task:
	local task_number = 1
	local task_info = task_manager.get_task_manager( ).task_info
	local task_id = string.format( "%s%s", section_name, task_number )
	while ( task_manager.task_ini:section_exist( task_id ) ) do
		if ( (db.actor:get_task( task_id, true ) ~= nil) and (task_info[task_id]) ) then
			if ( (task_info[task_id].status ~= "fail") and (task_info[task_id].status ~= "completed") ) then
				drx_ql_current_cf_tasks[npc_id][1] = task_id
				return true
			end
		end
		task_number = (task_number + 1)
		task_id = string.format( "%s%s", section_name, task_number )
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- PRECONDITION FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_not_enemy function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Checks if a npc is an enemy of the player
--
--	Usage:
--		drx_ql_not_enemy( )
--
--	Parameters:
--		none
--
--	Return value (type: bool):
--		Returns true if the faction is not an enemy of the player faction, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified June 22, 2019
-- ------------------------------------------------------------------------------------------------

-- Check if faction is enemy of player:
function drx_ql_not_enemy( speaker_1, speaker_2 )

	-- Get npc faction:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_faction = character_community( npc )
	npc_faction = string.gsub( npc_faction, "actor_", "" )

	-- Get npc name to perform special check for trader communities:
	local npc_name = npc:name( )

	-- Special check for Sidorovich:
	if ( string.find( npc_name, "esc_m_trader" ) ) then
		npc_faction = "stalker"

	-- Special check for Sakharov:
	elseif ( string.find( npc_name, "yan_stalker_sakharov" ) ) then
		npc_faction = "ecolog"

	end

	-- Check if faction is enemy of the player:
	local is_enemy = false
	if ( relation_registry.community_relation( npc_faction, alife( ):actor( ):community( ) ) <= game_relations.ENEMIES ) then
		is_enemy = true
	end

	-- Set return value:
	return (not is_enemy)

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_not_same_faction function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player is the same faction as the current NPC
--
--	Usage:
--		drx_ql_actor_not_same_faction( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the player is not the same faction as the NPC, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified September 25, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor is not same faction as npc:
function drx_ql_actor_not_same_faction( speaker_1, speaker_2 )

	-- Get npc faction:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_faction = character_community( npc )
	npc_faction = string.gsub( npc_faction, "actor_", "" )

	-- Get npc name to perform special check for trader communities:
	local npc_name = npc:name( )

	-- Special check for Sidorovich:
	if ( string.find( npc_name, "esc_m_trader" ) ) then
		npc_faction = "stalker"

	-- Special check for Sakharov:
	elseif ( string.find( npc_name, "yan_stalker_sakharov" ) ) then
		npc_faction = "ecolog"

	end

	-- Get player faction:
	local actor_faction = alife( ):actor( ):community( )
	actor_faction = string.gsub( actor_faction, "actor_", "" )

	-- Check if factions are same:
	if ( actor_faction == npc_faction ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_dont_has_npc_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player already has a task from the current NPC
--
--	Usage:
--		drx_ql_dont_has_npc_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_task_giver_{npc_id} (type: int)
--			- Count of currently active tasks the npc has given the player
--
--	Return value (type: bool):
--		Returns true if the player does not have a task from the NPC, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified September 29, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has npc task:
function drx_ql_dont_has_npc_task( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if npc has already given task, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if npc has already given task, npc id is invalid" )
		return false
	end

	-- Check if the npc has already given the player a task that is still active:
	if ( utils.load_var( db.actor, string.format( "drx_ql_task_giver_%s", npc_id ), 0 ) > 0 ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_npc_not_temp function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the current npc is temporary, only spawned for a specific task
--
--	Usage:
--		drx_ql_npc_not_temp( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[task_specific_squads] (type: string, squad name sub-strings)
--				- Squad name sub-strings for squads that are only spawned for specific tasks
--
--	Return value (type: bool):
--		Returns true if the npc is not temporary, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified September 02, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if npc is temporary:
function drx_ql_npc_not_temp( speaker_1, speaker_2 )

	-- Get the location of the main config file:
	local drx_ql_config_ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not drx_ql_config_ini ) then
		printf( "DRX QL Error: Unable to determine if npc is temporary, config file not found" )
		return false
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if npc is temporary, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if npc is temporary, npc id is invalid" )
		return false
	end

	-- Get npc squad info:
	local npc_obj = alife( ):object( npc_id )
	if ( not npc_obj ) then
		printf( "DRX QL Error: Unable to determine if npc is temporary, could not retrieve npc obj" )
		return false
	end
	local squad = get_object_squad( npc_obj )
	if ( not squad ) then
		printf( "DRX QL Error: Unable to determine if npc is temporary, unable to get npc squad object" )
		return false
	end
	local squad_name = squad:section_name( )
	if ( not squad_name ) then
		printf( "DRX QL Error: Unable to determine if npc is temporary, unable to get npc squad name" )
		return false
	end

	-- Check if npc squad is temporary:
	local tempsquad_list = alun_utils.collect_section( drx_ql_config_ini, "task_specific_squads" )
	if ( #tempsquad_list > 0 ) then
		for i = 1, ( #tempsquad_list ) do
			if ( string.find( squad_name, tempsquad_list[i] ) ) then
				return false
			end
		end
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_on_start_game function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the player is supposed to start the game at the current NPC
--
--	Usage:
--		drx_ql_actor_on_start_game( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the player is starting the game at the current NPC, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 07, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor is starting game at current npc:
function drx_ql_actor_on_start_game( speaker_1, speaker_2 )

	-- Get npc name:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_name = npc:section( )
	if ( not npc_name ) then
		printf( "DRX QL Error: Unable to determine if actor is starting game at current npc, npc name is invalid" )
		return false
	end
	if ( npc:section( ) == "m_trader" ) then
		npc_name = npc:name( )
	end

	-- Check if the player should be starting the game at the current npc:
	if ( not has_alife_info( string.format( "drx_ql_start_game_%s", npc_name ) ) ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_not_on_start_game function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the player is supposed to start the game at the current NPC
--
--	Usage:
--		drx_ql_actor_not_on_start_game( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the player is starting the game at the current NPC, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 08, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor is starting game at current npc:
function drx_ql_actor_not_on_start_game( speaker_1, speaker_2 )

	-- Set return value:
	return (not drx_ql_actor_on_start_game( speaker_1, speaker_2 ))

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_is_end_game function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has met the requirements to start the end game questline
--
--	Usage:
--		drx_ql_is_end_game( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_current_task_number (type: int)
--			Current meet honcho task number
--		drx_ql_total_task_number (type: int)
--			Total number of meet honcho tasks to complete
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[end_game_factions] (type: string, faction names)
--				- List of actor factions that can trigger the endgame questline
--			[end_game_task]
--				preconditions (type: string, cdl of infoportions)
--					- List of required infoportions to trigger endgame questline
--				extension (type: int)
--					- Maximum number of meet tasks to complete after meeting endgame questline preconditions
--				meet_honcho (type: string, npc id)
--					- Honcho to meet to start the endgame questline
--				meet_honcho_squad (type: string, squad id)
--					- Squad name of endgame honcho
--				meet_honcho_smart (type: string, smart terrain id)
--					- Smart terrain to spawn endgame honcho at
--
--	Return value (type: bool):
--		Returns true if the end game questline can be started, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified February 09, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if end game questline can be started:
function drx_ql_is_end_game( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if end game questline, db.actor not available" )
		return false
	end

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if end game questline, cannot locate ini file" )
		return false
	end

	-- Check if the minimum number of meet honcho tasks has been met:
	local current_tasks = utils.load_var( db.actor, "drx_ql_current_task_number", 0 )
	local total_tasks = utils.load_var( db.actor, "drx_ql_total_task_number", 1 )
	if ( current_tasks < total_tasks ) then
		return false
	end

	-- Get actor faction:
	local actor_faction = alife( ):actor( ):community( )
	if ( (not actor_faction) or (actor_faction == "") ) then
		printf( "DRX QL Error: Unable to determine if end game questline, actor does not belong to any community" )
		return false
	end
	actor_faction = string.gsub( actor_faction, "actor_", "" )

	-- Check if actor faction is faction that can trigger endgame:
	local endgame_factions = alun_utils.collect_section( ini, "end_game_factions" )
	if ( (not endgame_factions) or (#endgame_factions < 1) ) then
		return false
	end
	local can_trigger = false
	for i = 1, ( #endgame_factions ) do
		if ( actor_faction == endgame_factions[i] ) then
			can_trigger = true
			break
		end
	end
	if ( not can_trigger ) then
		return false
	end

	-- Check if required infoportions have been triggered:
	local precondition_list = {}
	local precond_string = ini:r_string_ex( "end_game_task", "preconditions" )
	if ( (precond_string) and (precond_string ~= "") ) then
		precondition_list = utils.parse_names( precond_string )
	end
	if ( (precondition_list) and (#precondition_list > 0) ) then
		for m = 1, ( #precondition_list ) do
			if ( not has_alife_info( precondition_list[m] ) ) then
				return false
			end
		end
	end

	-- If all preconditions met for first time, extend questline:
	if ( not has_alife_info( "drx_ql_info_endgame_preconds_met" ) ) then
		local extension = (ini:r_float_ex( "end_game_task", "extension" ) or 0)
		if ( extension > 1 ) then
			extension = math.random( extension )
		end
		if ( (extension) and (total_tasks ~= current_tasks) and (total_tasks < (current_tasks + extension)) ) then
			utils.save_var( db.actor, "drx_ql_total_task_number", (current_tasks + extension) )
		end
		db.actor:give_info_portion( "drx_ql_info_endgame_preconds_met" )
		return false
	end

	-- Check if endgame honcho alive:
	local honcho_alive = true
	local next_honcho = ini:r_string_ex( "end_game_task", "meet_honcho" )
	if ( not next_honcho ) then
		printf( "DRX QL Error: Unable to start end game questline, no endgame honcho specified" )
		return false
	end
	local honcho_id = get_story_object_id( next_honcho )
	if ( not honcho_id ) then
		honcho_alive = false
	else
		local honcho_obj = alife( ):object( honcho_id )
		if ( (not honcho_obj) or (not honcho_obj:alive( )) ) then
			honcho_alive = false
		end
	end

	-- If honcho is dead then spawn replacement:
	if ( not honcho_alive ) then

		-- Send update to console:
		printf( "DRX QL: Endgame honcho is dead, spawning replacement" )

		-- Get smart to spawn endgame honcho at:
		local smart_name = ini:r_string_ex( "end_game_task", "meet_honcho_smart" )
		if ( not smart_name ) then
			printf( "DRX QL Error: Unable to spawn replacement endgame honcho, no endgame honcho spawn area specified" )
			return false
		end
		local smart = SIMBOARD.smarts_by_names[smart_name]
		if ( smart == nil ) then
			printf( "DRX QL Error: Unable to spawn replacement endgame honcho, target smart invalid" )
			return false
		end

		-- Spawn the squad:
	 	local squad_name = ini:r_string_ex( "end_game_task", "meet_honcho_squad" )
		if ( not squad_name ) then
			printf( "DRX QL Error: Unable to spawn replacement endgame honcho, no endgame honcho squad name specified" )
			return false
		end
		local squad = SIMBOARD:create_squad( smart, squad_name )
		if ( not squad ) then
			printf( "DRX QL Error: Unable to start end game questline, endgame honcho squad could not be spawned" )
			return false
		end

		-- Set squad target smart:
		squad.action_condlist = alun_utils.parse_condlist( smart_name )

		-- Setup squad:
		for k in squad:squad_members( ) do
			local se_obj = (k.object or (k.id and alife( ):object( k.id )))
			if ( se_obj ) then
				SIMBOARD:setup_squad_and_group( se_obj )
			end
		end

		-- Send update to console:
		printf( "DRX QL: Replacement endgame honcho spawned" )

	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_not_is_end_game function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not the player has met the requirements to start the end game questline
--
--	Usage:
--		drx_ql_not_is_end_game( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the end game questline can be started, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 15, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if end game questline can be started:
function drx_ql_not_is_end_game( speaker_1, speaker_2 )

	-- Set return value:
	return ( not drx_ql_is_end_game( speaker_1, speaker_2 ) )

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_extend_questline function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Extends the questline by adding more tasks to the required minimum task count
--
--	Usage:
--		drx_ql_extend_questline( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_current_task_number (type: int)
--			Current meet honcho task number
--		drx_ql_total_task_number (type: int)
--			Total number of meet honcho tasks to complete
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[task_number_range]
--				extension_count (type: int)
--					- Number of meet honcho tasks to add each time player extends the questline
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 15, 2018
-- ------------------------------------------------------------------------------------------------

-- Extend the questline:
function drx_ql_extend_questline( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to extend questline, db.actor not available" )
		return
	end

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to extend questline, cannot locate ini file" )
		return
	end

	-- Get the current task count:
	local task_count = utils.load_var( db.actor, "drx_ql_current_task_number", 0 )

	-- Get the number of tasks to add:
	local extension = (ini:r_float_ex( "task_number_range", "extension_count" ) or 0)

	-- Save the new minimum required task count:
	utils.save_var( db.actor, "drx_ql_total_task_number", (task_count + extension) )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_meet_current_honcho function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the player is supposed to meet the current NPC to get a storyline task
--
--	Usage:
--		drx_ql_actor_meet_current_honcho( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the player is supposed to meet the current NPC, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 13, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor is supposed to meet current npc:
function drx_ql_actor_meet_current_honcho( speaker_1, speaker_2 )

	-- Get npc name:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_name = npc:section( )
	if ( not npc_name ) then
		printf( "DRX QL Error: Unable to determine if actor is supposed to meet current npc, npc name is invalid" )
		return false
	end
	if ( npc:section( ) == "m_trader" ) then
		npc_name = npc:name( )
	end

	-- Check if the player should be meeting the current npc to get a storyline task:
	if ( not has_alife_info( string.format( "drx_ql_meet_honcho_%s", npc_name ) ) ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_actor_not_meet_current_honcho function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the player is not supposed to meet the current NPC to get a storyline task
--
--	Usage:
--		drx_ql_actor_not_meet_current_honcho( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the player is supposed to meet the current NPC, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 15, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if actor is not supposed to meet current npc:
function drx_ql_actor_not_meet_current_honcho( speaker_1, speaker_2 )

	-- Set return value:
	return (not drx_ql_actor_meet_current_honcho( speaker_1, speaker_2 ))

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_mechanic_not_fully_upgraded function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not a mechanic is fully upgraded
--
--	Usage:
--		drx_ql_mechanic_not_fully_upgraded( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the mechanic is not fully upgraded, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 06, 2017
-- ------------------------------------------------------------------------------------------------

-- Check if the mechanic is fully upgraded:
function drx_ql_mechanic_not_fully_upgraded( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if mechanic is fully upgraded, db.actor not available" )
		return false
	end

	-- Get mechanic section name:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_section
	if ( npc:section( ) == "m_trader" ) then
		npc_section = npc:name( )
	else
		npc_section = npc:section( )
	end
	if ( not npc_section ) then
		printf( "DRX QL Error: Unable to determine if mechanic is fully upgraded, npc section is invalid" )
		return false
	end

	-- Check if the mechanic is fully upgraded:
	if ( db.actor:has_info( string.format( "%s_upgrade_tier_3", npc_section ) ) ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_is_hostage_task_giver function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the current NPC is a hostage task giver
--		- Modification of dialogs_axr_companion.is_hostage_task_giver (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_is_hostage_task_giver( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_hostage_giver_{npc_id} (type: bool)
--			- Flag indicating whether or not the npc is a current hostage task giver
--
--	Return value (type: bool):
--		Returns true if the NPC is a current hostage task giver, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 09, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if current NPC is hostage task giver:
function drx_ql_is_hostage_task_giver( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if npc is hostage task giver, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if npc is hostage task giver, npc id is invalid" )
		return
	end

	-- Determine if npc is hostage task giver:
	if ( utils.load_var( db.actor, string.format( "drx_ql_hostage_giver_%s", npc_id ), false ) ) then
		return true
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_is_not_hostage_task_giver function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the current NPC is a hostage task giver
--		- Modification of dialogs_axr_companion.is_not_hostage_task_giver(CoC 1.5b r4)
--
--	Usage:
--		drx_ql_is_not_hostage_task_giver( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_hostage_giver_{npc_id} (type: bool)
--			- Flag indicating whether or not the npc is a current hostage task giver
--
--	Return value (type: bool):
--		Returns false if the NPC is a current hostage task giver, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 09, 2017
-- ------------------------------------------------------------------------------------------------

-- Determine if current NPC is hostage task giver:
function drx_ql_is_not_hostage_task_giver( speaker_1, speaker_2 )

	-- Set return value:
	return (not drx_ql_is_hostage_task_giver( speaker_1, speaker_2 ))

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_has_hidden_target function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has a target id that is hidden to the actor
--
--	Usage:
--		drx_ql_has_hidden_target( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the actor has a hidden target, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the actor has a hidden target:
function drx_ql_has_hidden_target( speaker_1, speaker_2 )

	-- Check if a valid hidden target exists:
	for npc_id, task_id in pairs( xr_effects.drx_ql_hidden_targets ) do
		local se_obj = alife( ):object( npc_id )
		if ( (se_obj) and (se_obj:alive( )) ) then
			return true
		end
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_has_hidden_assassin function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has a assassin that is hidden to the actor
--
--	Usage:
--		drx_ql_has_hidden_assassin( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_assassin_squad_id (type: squad id)
--			- Id of the assassin squad for a hunted task
--
--	Return value (type: bool):
--		Returns true if the actor has a hidden assassin, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified February 17, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if the actor has a hidden assassin:
function drx_ql_has_hidden_assassin( speaker_1, speaker_2 )

	-- Check if actor has a hidden assassin:
	if ( (db.actor) and (db.actor:has_info( "drx_ql_info_has_hunted_task" )) and (not db.actor:has_info( "drx_ql_info_assassin_known" )) ) then
		local assassin_squad_id = utils.load_var( db.actor, "drx_ql_assassin_squad_id" )
		if ( assassin_squad_id ) then
			local assassin_squad_obj = alife_object( assassin_squad_id )
			if ( assassin_squad_obj ) then
				local assassin_id = assassin_squad_obj:commander_id( )
				if ( assassin_id ) then
					local assassin_obj = alife_object( assassin_id )
					if ( assassin_obj and IsStalker( nil, assassin_obj:clsid( ) ) ) then
						if ( assassin_obj:alive( ) ) then
							return true
						end
					end
				end
			end
		end
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_has_undiscovered_float_fetch function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has an undiscovered float fetch task
--
--	Usage:
--		drx_ql_has_undiscovered_float_fetch( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{task_id}_helper (type: string, squad id)
--			- Squad id of the helper for the specified float fetch task
--
--	Return value (type: bool):
--		Returns true if the actor has an undiscovered float fetch task, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 24, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the actor has undiscovered float fetch task:
function drx_ql_has_undiscovered_float_fetch( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has undiscovered float fetch task, db.actor not available" )
		return false
	end

	-- Check if actor has at least one undiscovered float fetch task:
	if ( #xr_effects.drx_ql_float_fetch_tasks <= 0 ) then
		return false
	end

	-- Check each task for helper squad:
	for task_index = 1, ( #xr_effects.drx_ql_float_fetch_tasks ) do
		if ( not drx_ql_task_has_helper( xr_effects.drx_ql_float_fetch_tasks[task_index] ) ) then
			return true
		end
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_task_has_helper function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Checks if a task has a valid helper squad
--
--	Usage:
--		drx_ql_task_has_helper( task_id )
--
--	Parameters:
--		task_id (type: string, task id)
--			- ID of the task to investigate
--
--	Persistent storage:
--		{task_id}_helper (type: string, squad id)
--			- Squad id of the helper for the specified float fetch task
--
--	Return value (type: bool):
--		Returns true if the task has a valid helper squad, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 24, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the task has a valid helper squad:
function drx_ql_task_has_helper( task_id )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if task has helper squad, db.actor not available" )
		return false
	end

	-- Get the squad id of the helper squad:
	local squad_id = utils.load_var( db.actor, string.format( "%s_helper", task_id ) )
	if ( not squad_id ) then
		return false
	end

	-- Check if the squad is still companions with the actor:
	local squad = axr_companions.companion_squads[squad_id]
	if ( not squad ) then
		return false
	end

	-- Ensure at least one member is alive:
	for member in squad:squad_members( ) do
		local member_obj = (member.id and (db.storage[member.id] and db.storage[member.id].object))
		if ( member_obj and member_obj:alive( ) ) then
			return true
		end
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_hidden_target_not_asked function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the NPC has not recently been asked about a hidden target
--
--	Usage:
--		drx_ql_hidden_target_not_asked( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{NPC storage}:drx_ql_ht_time_last_asked (type: int, time)
--			- Time the npc was last asked about a hidden target
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[ht_task_props]
--				ht_inquiry_reset_time (type: int, seconds)
--					- Length of time before an NPC can be asked about a hidden target again
--
--	Return value (type: bool):
--		Returns true if the NPC has not been recently asked about a hidden target, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc has not been recently asked about a hidden target:
function drx_ql_hidden_target_not_asked( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked about hidden target, cannot locate ini file" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked about hidden target, npc is invalid" )
		return
	end

	-- Check if NPC has never been asked about a hidden target:
	local time_last_checked = utils.load_ctime( npc, "drx_ql_ht_time_last_asked" )
	if ( not time_last_checked ) then
		return true
	end

	-- Check if time last asked was longer than reset time:
	local ht_reset_time = (ini:r_float_ex( "ht_task_props", "ht_inquiry_reset_time" ) or 0)
	if ( game.get_game_time( ):diffSec( time_last_checked ) > ht_reset_time ) then
		return true
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_hidden_assassin_not_asked function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the NPC has not recently been asked about a hidden assassin
--
--	Usage:
--		drx_ql_hidden_assassin_not_asked( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_hunted_task_giver_id (type: npc id)
--			- Id of the npc who gave hunted task
--		{NPC storage}:drx_ql_ha_time_last_asked (type: int, time)
--			- Time the npc was last asked about a hidden assassin
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[hunted_task_props]
--				inquiry_reset_time (type: int, seconds)
--					- Length of time before an NPC can be asked about a hidden assassin again
--
--	Return value (type: bool):
--		Returns true if the NPC has not been recently asked about a hidden assassin, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified February 17, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc has not been recently asked about a hidden assassin:
function drx_ql_hidden_assassin_not_asked( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked about hidden assassin, cannot locate ini file" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked about hidden assassin, npc is invalid" )
		return false
	end
	local npc_id = npc:id( )

	-- Check if NPC is hidden assassin task giver:
	local task_giver_id = utils.load_var( db.actor, "drx_ql_hunted_task_giver_id" )
	if ( (task_giver_id) and (npc_id == task_giver_id) ) then
		return false
	end

	-- Check if NPC has never been asked about a hidden assassin:
	local time_last_checked = utils.load_ctime( npc, "drx_ql_ha_time_last_asked" )
	if ( not time_last_checked ) then
		return true
	end

	-- Check if time last asked was longer than reset time:
	local reset_time = (ini:r_float_ex( "hunted_task_props", "inquiry_reset_time" ) or 0)
	if ( game.get_game_time( ):diffSec( time_last_checked ) > reset_time ) then
		return true
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_news_not_asked function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the NPC has not recently been asked for news
--
--	Usage:
--		drx_ql_news_not_asked( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{NPC storage}:drx_ql_news_time_last_asked (type: int, time)
--			- Time the npc was last asked for news
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[local_warning_props]
--				news_reset_time (type: int, seconds)
--					- Length of time before an NPC can be asked for news again
--
--	Return value (type: bool):
--		Returns true if the NPC has not been recently asked for news, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified February 20, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc has not been recently asked for news:
function drx_ql_news_not_asked( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked for news, cannot locate ini file" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked for news, npc is invalid" )
		return false
	end
	local npc_id = npc:id( )

	-- Check if NPC has never been asked for news:
	local time_last_checked = utils.load_ctime( npc, "drx_ql_news_time_last_asked" )
	if ( not time_last_checked ) then
		return true
	end

	-- Check if time last asked was longer than reset time:
	local reset_time = (ini:r_float_ex( "local_warning_props", "news_reset_time" ) or 0)
	if ( game.get_game_time( ):diffSec( time_last_checked ) > reset_time ) then
		return true
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_float_fetch_not_asked function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the NPC has not recently been asked about an undiscovered float fetch
--
--	Usage:
--		drx_ql_float_fetch_not_asked( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{NPC storage}:drx_ql_ff_time_last_asked (type: int, time)
--			- Time the npc was last asked about an undicovered float fetch task
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[ff_task_props]
--				ff_inquiry_reset_time (type: int, seconds)
--					- Length of time before an NPC can be asked about an undiscovered float fetch task again
--
--	Return value (type: bool):
--		Returns true if the NPC has not been recently asked about an undiscovered float fetch, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc has not been recently asked about an undiscovered float fetch task:
function drx_ql_float_fetch_not_asked( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked about undiscovered float fetch task, cannot locate ini file" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to determine if npc has been asked about undiscovered float fetch task, npc is invalid" )
		return
	end

	-- Check if NPC has never been asked about undiscovered float fetch task:
	local time_last_checked = utils.load_ctime( npc, "drx_ql_ff_time_last_asked" )
	if ( not time_last_checked ) then
		return true
	end

	-- Check if time last asked was longer than reset time:
	local ff_reset_time = (ini:r_float_ex( "ff_task_props", "ff_inquiry_reset_time" ) or 0)
	if ( game.get_game_time( ):diffSec( time_last_checked ) > ff_reset_time ) then
		return true
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_float_fetch_not_task_giver  function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the NPC is a undiscovered float fetch task giver
--
--	Usage:
--		drx_ql_float_fetch_not_task_giver( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the NPC is not an undiscovered float fetch task giver, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc is an undiscovered float fetch task giver:
function drx_ql_float_fetch_not_task_giver( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to determine if npc is undiscovered float fetch task giver, npc is invalid" )
		return
	end

	-- Check if NPC is undiscovered float fetch task giver:
	for i =1, ( #xr_effects.drx_ql_float_fetch_tasks ) do
		local tsk = task_manager.get_task_manager( ).task_info[xr_effects.drx_ql_float_fetch_tasks[i]]
		if ( (tsk) and (tsk.task_giver_id) and (tsk.task_giver_id == npc:id( )) ) then
			return false
		end
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_determine_help  function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the NPC will be helpful for an undiscovered float fetch task
--
--	Usage:
--		drx_ql_ff_determine_help( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_ff_npc_is_helpful (type: bool)
--			- Whether or not the current NPC will be helpful for a undiscovered float fetch task
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[ff_task_props]
--				ff_help_chance (type: float, decimal percent)
--					- Percent chance an NPC will offer to help find an undiscovered float fetch item
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc will be helpful for an undiscovered float fetch task:
function drx_ql_ff_determine_help( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if the npc will be helpful for an undiscovered float fetch task, cannot locate ini file" )
		return
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if the npc will be helpful for an undiscovered float fetch task, db.actor not available" )
		return
	end

	-- Determine if NPC will be helpful:
	local is_helpful = false
	local help_chance = (ini:r_float_ex( "ff_task_props", "ff_help_chance" ) or 0)
	if ( help_chance > 0 ) then
		if ( math.random( ) <= help_chance ) then
			is_helpful = true
		end
	end

	-- Store setting:
	utils.save_var( db.actor, "drx_ql_ff_npc_is_helpful", is_helpful )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_npc_is_helpful  function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Reports if the NPC was determined to be helpful for an undiscovered float fetch task
--
--	Usage:
--		drx_ql_ff_npc_is_helpful( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_ff_npc_is_helpful (type: bool)
--			- Whether or not the current NPC will be helpful for a undiscovered float fetch task
--
--	Return value (type: bool):
--		Returns true if the NPC is helpful, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc is helpful for an undiscovered float fetch task:
function drx_ql_ff_npc_is_helpful( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if the npc is helpful for an undiscovered float fetch task, db.actor not available" )
		return
	end

	-- Determine if NPC is helpful:
	local is_helpful = utils.load_var( db.actor, "drx_ql_ff_npc_is_helpful", false )

	-- Set return value:
	return is_helpful

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_npc_not_is_helpful  function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Reports if the NPC was determined to be helpful for an undiscovered float fetch task
--
--	Usage:
--		drx_ql_ff_npc_not_is_helpful( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the NPC is helpful, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if the npc is helpful for an undiscovered float fetch task:
function drx_ql_ff_npc_not_is_helpful( speaker_1, speaker_2 )

	-- Set return value:
	return ( not drx_ql_ff_npc_is_helpful( speaker_1, speaker_2 ) )

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_mark_ht_asked_time function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Stores the time an NPC was asked about a hidden target
--
--	Usage:
--		drx_ql_mark_ht_asked_time( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{NPC storage}:drx_ql_ht_time_last_asked (type: int, time)
--			- Time the npc was last asked about a hidden target
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Store npc asked about hidden target time:
function drx_ql_mark_ht_asked_time( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to store hidden target asked time, npc is invalid" )
		return
	end

	-- Store the current time:
	utils.save_ctime( npc, "drx_ql_ht_time_last_asked", game.get_game_time( ) )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_mark_ha_asked_time function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Stores the time an NPC was asked about a hidden assassin
--
--	Usage:
--		drx_ql_mark_ha_asked_time( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{NPC storage}:drx_ql_ha_time_last_asked (type: int, time)
--			- Time the npc was last asked about a hidden assassin
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified February 17, 2019
-- ------------------------------------------------------------------------------------------------

-- Store npc asked about hidden assassin time:
function drx_ql_mark_ha_asked_time( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to store hidden assassin asked time, npc is invalid" )
		return
	end

	-- Store the current time:
	utils.save_ctime( npc, "drx_ql_ha_time_last_asked", game.get_game_time( ) )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_mark_ff_asked_time function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Stores the time an NPC was asked about an undiscovered float fetch task
--
--	Usage:
--		drx_ql_mark_ff_asked_time( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{NPC storage}:drx_ql_ff_time_last_asked (type: int, time)
--			- Time the npc was last asked about an undiscovered float fetch task
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Store npc asked about undiscovered float fetch time:
function drx_ql_mark_ff_asked_time( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to store undiscovered float fetch asked time, npc is invalid" )
		return
	end

	-- Store the current time:
	utils.save_ctime( npc, "drx_ql_ff_time_last_asked", game.get_game_time( ) )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ht_inquiry_reply_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for an NPC responding to a general hidden target inquiry
--
--	Usage:
--		drx_ql_ht_inquiry_reply_text( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_hidden_target_inquiry_reply_{x}
--				- Text to display when NPC responds to general hidden target inquiry ({x} = sequential int starting with 1)
--
--	Return value (type: string):
--		Returns the text to display for the NPC reply
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Text to display for an NPC responding to a general hidden target inquiry:
function drx_ql_ht_inquiry_reply_text( speaker_1, speaker_2 )

	-- Pick a random reply phrase:
	local retstring = game.translate_string( drx_ql_random_phrase( "drx_ql_str_hidden_target_inquiry_reply" ) )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_inquiry_reply_helpful_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for an NPC willing to help on an undiscovered float fetch task inquiry
--
--	Usage:
--		drx_ql_ff_inquiry_reply_helpful_text( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_float_fetch_inquiry_reply_helpful_{x}
--				- Text to display when NPC is willing to help on an undiscovered float fetch inquiry ({x} = sequential int starting with 1)
--
--	Return value (type: string):
--		Returns the text to display for the NPC reply
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Text to display for an NPC responding to a undiscovered float fetch inquiry:
function drx_ql_ff_inquiry_reply_helpful_text( speaker_1, speaker_2 )

	-- Pick a random reply phrase:
	local retstring = game.translate_string( drx_ql_random_phrase( "drx_ql_str_float_fetch_inquiry_reply_helpful" ) )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_inquiry_reply_no_help_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for an NPC unwilling to help on an undiscovered float fetch task inquiry
--
--	Usage:
--		drx_ql_ff_inquiry_reply_no_help_text( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_float_fetch_inquiry_reply_no_help_{x}
--				- Text to display when NPC is unwilling to help on an undiscovered float fetch inquiry ({x} = sequential int starting with 1)
--
--	Return value (type: string):
--		Returns the text to display for the NPC reply
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Text to display for an NPC responding to a undiscovered float fetch inquiry:
function drx_ql_ff_inquiry_reply_no_help_text( speaker_1, speaker_2 )

	-- Pick a random reply phrase:
	local retstring = game.translate_string( drx_ql_random_phrase( "drx_ql_str_float_fetch_inquiry_reply_no_help" ) )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ht_target_{x}_exists function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not a hidden target is valid
--
--	Usage:
--		drx_ql_ht_target_{x}_exists( )
--			- {x} = int between 1 and 5
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the target is valid, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if hidden target 1 is valid:
function drx_ql_ht_target_1_exists( speaker_1, speaker_2 )
	return drx_ql_ht_target_exists( 1 )
end

-- Determine if hidden target 2 is valid:
function drx_ql_ht_target_2_exists( speaker_1, speaker_2 )
	return drx_ql_ht_target_exists( 2 )
end

-- Determine if hidden target 3 is valid:
function drx_ql_ht_target_3_exists( speaker_1, speaker_2 )
	return drx_ql_ht_target_exists( 3 )
end

-- Determine if hidden target 4 is valid:
function drx_ql_ht_target_4_exists( speaker_1, speaker_2 )
	return drx_ql_ht_target_exists( 4 )
end

-- Determine if hidden target 5 is valid:
function drx_ql_ht_target_5_exists( speaker_1, speaker_2 )
	return drx_ql_ht_target_exists( 5 )
end

-- Main function to determine if hidden target is valid:
function drx_ql_ht_target_exists( target_index )

	-- Var for storing return value:
	local target_exists = false

	-- Check if target at specified index is valid:
	local index = 1
	for target_id, task_id in pairs( xr_effects.drx_ql_hidden_targets ) do
		local se_obj = alife( ):object( target_id )
		if ( (se_obj) and (se_obj:alive( )) ) then
			if ( index == target_index ) then
				target_exists = true
				break
			end
			index = (index + 1)
		end
	end

	-- Set return value:
	return target_exists

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_task_{x}_exists function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not an unknown float fetch task exists in the global array
--
--	Usage:
--		drx_ql_ff_task_{x}_exists( )
--			- {x} = int between 1 and 5
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the task exists, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 24, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if task 1 is valid:
function drx_ql_ff_task_1_exists( speaker_1, speaker_2 )
	return drx_ql_ff_task_exists( 1 )
end

-- Determine if task 2 is valid:
function drx_ql_ff_task_2_exists( speaker_1, speaker_2 )
	return drx_ql_ff_task_exists( 2 )
end

-- Determine if task 3 is valid:
function drx_ql_ff_task_3_exists( speaker_1, speaker_2 )
	return drx_ql_ff_task_exists( 3 )
end

-- Determine if task 4 is valid:
function drx_ql_ff_task_4_exists( speaker_1, speaker_2 )
	return drx_ql_ff_task_exists( 4 )
end

-- Determine if task 5 is valid:
function drx_ql_ff_task_5_exists( speaker_1, speaker_2 )
	return drx_ql_ff_task_exists( 5 )
end

-- Main function to determine if task is valid:
function drx_ql_ff_task_exists( task_index )

	-- Check if task at specified index is valid:
	if ( #xr_effects.drx_ql_float_fetch_tasks < task_index ) then
		return false
	end

	-- Check if specified task already has a helper:
	if ( drx_ql_task_has_helper( xr_effects.drx_ql_float_fetch_tasks[task_index] ) ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ht_inquiry_target_{x}_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for the actor asking about hidden target 1
--
--	Usage:
--		drx_ql_ht_inquiry_target_{x}_text( )
--			- {x} = int between 1 and 5
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_{faction_name}_collective (type: string)
--				- Text to use for faction name when referring to member as part of collective
--			drx_ql_str_ht_specific_inquiry_{x}
--				- Text to display when actor asks about a specific hidden target ({x} = sequential int starting with 1)
--
--	Return value (type: string):
--		Returns the text to display
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Text to display for the actor asking about hidden target 1:
function drx_ql_ht_inquiry_target_1_text( speaker_1, speaker_2 )
	return drx_ql_ht_inquiry_target_text( 1 )
end

-- Text to display for the actor asking about hidden target 2:
function drx_ql_ht_inquiry_target_2_text( speaker_1, speaker_2 )
	return drx_ql_ht_inquiry_target_text( 2 )
end

-- Text to display for the actor asking about hidden target 3:
function drx_ql_ht_inquiry_target_3_text( speaker_1, speaker_2 )
	return drx_ql_ht_inquiry_target_text( 3 )
end

-- Text to display for the actor asking about hidden target 4:
function drx_ql_ht_inquiry_target_4_text( speaker_1, speaker_2 )
	return drx_ql_ht_inquiry_target_text( 4 )
end

-- Text to display for the actor asking about hidden target 5:
function drx_ql_ht_inquiry_target_5_text( speaker_1, speaker_2 )
	return drx_ql_ht_inquiry_target_text( 5 )
end

-- Main function for text to display for the actor asking about hidden target:
function drx_ql_ht_inquiry_target_text( target_index )

	-- Get hidden target id:
	local hidden_target_id = nil
	local index = 1
	for target_id, task_id in pairs( xr_effects.drx_ql_hidden_targets ) do
		local se_obj = alife( ):object( target_id )
		if ( (se_obj) and (se_obj:alive( )) ) then
			if ( index == target_index ) then
				hidden_target_id = target_id
				break
			end
			index = (index + 1)
		end
	end

	-- Ensure a target was located:
	if ( not hidden_target_id ) then
		printf( "DRX QL Error: Unable to generate hidden target text, no valid target at index %s", target_index )
		return ""
	end

	-- Get the target object:
	local target_obj = alife( ):object( hidden_target_id )
	if ( not target_obj ) then
		printf( "DRX QL Error: Unable to generate hidden target text, target object at index %s is invalid", target_index )
		return ""
	end

	-- Format phrase:
	local target_faction = game.translate_string( string.format( "drx_ql_str_%s_collective", target_obj:community( ) ) )
	local target_name = target_obj:character_name( )
	local retstring = string.format( game.translate_string( drx_ql_random_phrase( "drx_ql_str_ht_specific_inquiry" ) ), target_faction, target_name )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_inquiry_task_{x}_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for the actor asking for help with an undiscovered float fetch task
--
--	Usage:
--		drx_ql_ff_inquiry_task_{x}_text( )
--			- {x} = int between 1 and 5
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_ff_specific_inquiry_{x}
--				- Text to display when actor asks about a specific hidden target ({x} = sequential int starting with 1)
--
--	Return value (type: string):
--		Returns the text to display
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 23, 2018
-- ------------------------------------------------------------------------------------------------

-- Text to display for the actor asking about float fetch task 1:
function drx_ql_ff_inquiry_task_1_text( speaker_1, speaker_2 )
	return drx_ql_ff_inquiry_task_text( 1 )
end

-- Text to display for the actor asking about float fetch task 2:
function drx_ql_ff_inquiry_task_2_text( speaker_1, speaker_2 )
	return drx_ql_ff_inquiry_task_text( 2 )
end

-- Text to display for the actor asking about float fetch task 3:
function drx_ql_ff_inquiry_task_3_text( speaker_1, speaker_2 )
	return drx_ql_ff_inquiry_task_text( 3 )
end

-- Text to display for the actor asking about float fetch task 4:
function drx_ql_ff_inquiry_task_4_text( speaker_1, speaker_2 )
	return drx_ql_ff_inquiry_task_text( 4 )
end

-- Text to display for the actor asking about float fetch task 5:
function drx_ql_ff_inquiry_task_5_text( speaker_1, speaker_2 )
	return drx_ql_ff_inquiry_task_text( 5 )
end

-- Main function for text to display for the actor asking about float fetch task:
function drx_ql_ff_inquiry_task_text( task_index )

	-- Var to store return string:
	local retstring = ""

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate undiscovered float fetch task text, db.actor not available" )
		return retstring
	end

	-- Get float fetch task id:
	if ( #xr_effects.drx_ql_float_fetch_tasks < task_index ) then
		printf( "DRX QL Error: Unable to generate undiscovered float fetch task text, no valid task at index %s", task_index )
		return retstring
	end
	local task_id = xr_effects.drx_ql_float_fetch_tasks[task_index]

	-- Get float fetch item text:
	local ff_item_id = utils.load_var( db.actor, string.format( "%s_fetch", task_id ) )
	if ( not ff_item_id ) then
		printf( "DRX QL Error: Unable to generate undiscovered float fetch task text, no float fetch item stored" )
		return retstring
	end
	local ff_item_text = game.translate_string( string.format( "%s_name", ff_item_id ) )

	-- Format the return string:
	retstring = string.format( game.translate_string( drx_ql_random_phrase( "drx_ql_str_ff_specific_inquiry" ) ), ff_item_text )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_determine_fee function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines the current fee for an NPC helping find an undiscovered float fetch task item
--
--	Usage:
--		drx_ql_ff_determine_fee( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_ff_npc_fee (type: int)
--			- Fee the current NPC is charging for help with an undiscovered float fetch task
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[ff_task_props]
--				ff_max_fee (type: float, RU)
--					- Maximum fee an NPC will charge to help find an undiscovered float fetch item
--				ff_min_fee (type: float, RU)
--					- Minimum fee an NPC will charge to help find an undiscovered float fetch item
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 24, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine NPC fee for help with undiscovered float fetch task:
function drx_ql_ff_determine_fee( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine undiscovered float fetch task fee, cannot locate ini file" )
		return
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine undiscovered float fetch task fee, db.actor not available" )
		return
	end

	-- Determine fee:
	local min_fee = (ini:r_float_ex( "ff_task_props", "ff_min_fee" ) or 0)
	local max_fee = (ini:r_float_ex( "ff_task_props", "ff_max_fee" ) or 0)
	local fee = math.random( math.ceil( (min_fee / 50) ), math.ceil( (max_fee / 50) ) )
	fee = (fee * 50)

	-- Store the NPC fee:
	utils.save_var( db.actor, "drx_ql_ff_npc_fee", fee )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_actor_has_fee function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has enough money to pay a undiscovered float fetch task help fee
--
--	Usage:
--		drx_ql_ff_actor_has_fee( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_ff_npc_fee (type: int)
--			- Fee the current NPC is charging for help with an undiscovered float fetch task
--
--	Return value (type: bool):
--		- Returns true if the actor has enough money to pay the fee, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 24, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has enough money to pay fee:
function drx_ql_ff_actor_has_fee( speaker_1, speaker_2 )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if actor has enough money to pay undiscovered float fetch task help fee, db.actor not available" )
		return
	end

	-- Get the NPC fee:
	local fee = utils.load_var( db.actor, "drx_ql_ff_npc_fee", 0 )
	if ( db.actor:money( ) < fee ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_actor_not_has_fee function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has enough money to pay a undiscovered float fetch task help fee
--
--	Usage:
--		drx_ql_ff_actor_not_has_fee( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_ff_npc_fee (type: int)
--			- Fee the current NPC is charging for help with an undiscovered float fetch task
--
--	Return value (type: bool):
--		- Returns false if the actor has enough money to pay the fee, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 24, 2018
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has enough money to pay fee:
function drx_ql_ff_actor_not_has_fee( speaker_1, speaker_2 )

	-- Set return value:
	return ( not drx_ql_ff_actor_has_fee( speaker_1, speaker_2 ) )

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_reply_fee_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for the npc replying about agreeing to help on an undiscovered float fetch task
--
--	Usage:
--		drx_ql_ff_reply_fee_text( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_ff_npc_fee (type: int)
--			- Fee the current NPC is charging for help with an undiscovered float fetch task
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_ff_specific_reply_{x}
--				- Text to display on npc agreeing to help look for float fetch item ({x} = sequential int starting with 1)
--
--	Return value (type: string):
--		Returns the text to display
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 24, 2018
-- ------------------------------------------------------------------------------------------------

-- Text to display for the npc replying about float fetch task:
function drx_ql_ff_reply_fee_text( speaker_1, speaker_2 )

	-- Var to store return string:
	local retstring = ""

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate undiscovered float fetch reply text, db.actor not available" )
		return retstring
	end

	-- Get stored NPC fee:
	local npc_fee = utils.load_var( db.actor, "drx_ql_ff_npc_fee", 0 )

	-- Format phrase:
	retstring = string.format( game.translate_string( drx_ql_random_phrase( "drx_ql_str_ff_specific_reply" ) ), npc_fee )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ff_give_help_{x} function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Gives the actor a companion to help locate an undiscovered float fetch task item
--
--	Usage:
--		drx_ql_ff_give_help_{x}( )
--			- {x} = int between 1 and 5
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_ff_npc_fee (type: int)
--			- Fee the current NPC is charging for help with an undiscovered float fetch task
--		{task_id}_helper (type: string, squad id)
--			- Squad id of the helper for the specified float fetch task
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 27, 2018
-- ------------------------------------------------------------------------------------------------

-- Give actor help for float fetch task 1:
function drx_ql_ff_give_help_1( speaker_1, speaker_2 )
	return drx_ql_ff_give_help( speaker_1, speaker_2, 1 )
end

-- Give actor help for float fetch task 2:
function drx_ql_ff_give_help_2( speaker_1, speaker_2 )
	return drx_ql_ff_give_help( speaker_1, speaker_2, 2 )
end

-- Give actor help for float fetch task 3:
function drx_ql_ff_give_help_3( speaker_1, speaker_2 )
	return drx_ql_ff_give_help( speaker_1, speaker_2, 3 )
end

-- Give actor help for float fetch task 4:
function drx_ql_ff_give_help_4( speaker_1, speaker_2 )
	return drx_ql_ff_give_help( speaker_1, speaker_2, 4 )
end

-- Give actor help for float fetch task 5:
function drx_ql_ff_give_help_5( speaker_1, speaker_2 )
	return drx_ql_ff_give_help( speaker_1, speaker_2, 5 )
end

-- Main function for giving the actor float fetch task help:
function drx_ql_ff_give_help( speaker_1, speaker_2, task_index )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to give float fetch task help, db.actor not available" )
		return
	end

	-- Get float fetch task id:
	if ( #xr_effects.drx_ql_float_fetch_tasks < task_index ) then
		printf( "DRX QL Error: Unable to give float fetch task help, no valid task at index %s", task_index )
		return retstring
	end
	local task_id = xr_effects.drx_ql_float_fetch_tasks[task_index]

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to give float fetch task help, npc id is invalid" )
		return
	end

	-- Get npc squad info:
	local npc_obj = alife( ):object( npc_id )
	if ( not npc_obj ) then
		printf( "DRX QL Error: Unable to give float fetch task help, could not retrieve npc obj" )
		return
	end
	local squad = get_object_squad( npc_obj )
	if ( not squad ) then
		printf( "DRX QL Error: Unable to give float fetch task help, unable to get npc squad object" )
		return
	end

	-- Actor pays NPC fee:
	local npc_fee = utils.load_var( db.actor, "drx_ql_ff_npc_fee", 0 )
	db.actor:give_money( -(npc_fee) )
	news_manager.relocate_money( db.actor, "out", npc_fee )

	-- Make npc squad companion:
	axr_companions.companion_squads[squad.id] = squad
	squad:set_squad_relation( game_relations.FRIENDS )
	SIMBOARD:assign_squad_to_smart( squad, nil )
	for member in squad:squad_members( ) do
		local member_obj = (member.id and (db.storage[member.id] and db.storage[member.id].object))
		if ( member_obj and member_obj:alive( ) ) then
			utils.se_obj_save_var( member.id, member.object:name( ), "companion", true )
			utils.se_obj_save_var( member.id, member.object:name( ), "companion_cannot_dismiss", false )
			utils.se_obj_save_var( member.id, member.object:name( ), "companion_cannot_teleport", nil )
			member_obj:inactualize_patrol_path( )
			axr_companions.setup_companion_logic( member_obj, db.storage[member.id], false, false )
		end
	end

	-- Save npc squad id as float fetch task helper:
	utils.save_var( db.actor, string.format( "%s_helper", task_id ), squad.id )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_become_companion function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Makes the current NPC squad companions to the actor
--
--	Usage:
--		drx_ql_become_companion( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 27, 2018
-- ------------------------------------------------------------------------------------------------

-- Main current npc companions:
function drx_ql_become_companion( speaker_1, speaker_2, task_index )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to make npc companion, npc id is invalid" )
		return
	end

	-- Get npc squad info:
	local npc_obj = alife( ):object( npc_id )
	if ( not npc_obj ) then
		printf( "DRX QL Error: Unable to give float fetch task help, could not retrieve npc obj" )
		return
	end
	local squad = get_object_squad( npc_obj )
	if ( not squad ) then
		printf( "DRX QL Error: Unable to make npc companion, unable to get npc squad object" )
		return
	end

	-- Make npc squad companion:
	axr_companions.companion_squads[squad.id] = squad
	squad:set_squad_relation( game_relations.FRIENDS )
	SIMBOARD:assign_squad_to_smart( squad, nil )
	for member in squad:squad_members( ) do
		local member_obj = (member.id and (db.storage[member.id] and db.storage[member.id].object))
		if ( member_obj and member_obj:alive( ) ) then
			utils.se_obj_save_var( member.id, member.object:name( ), "companion", true )
			utils.se_obj_save_var( member.id, member.object:name( ), "companion_cannot_dismiss", false )
			utils.se_obj_save_var( member.id, member.object:name( ), "companion_cannot_teleport", nil )
			member_obj:inactualize_patrol_path( )
			axr_companions.setup_companion_logic( member_obj, db.storage[member.id], false, false )
		end
	end

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_rg_transport_actor function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Transports the actor using river guide service
--
--	Usage:
--		drx_ql_rg_transport_actor( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_river_guide.ltx
--			[river_guide_settings]
--				fee (type: int, RU)
--					- River guide fee
--				south_guide (type: string, npc section name)
--					- Southern river guide
--			[north_dest_loc]
--				pos_x (type: float)
--					- X-position for north teleport destination
--				pos_y (type: float)
--					- Y-position for north teleport destination
--				pos_z (type: float)
--					- Z-position for north teleport destination
--				lvid (type: int, level vertex id)
--					- Level vertex id for north teleport destination
--				gvid (type: int, game vertex id)
--					- Game vertex id for north teleport destination
--			[south_dest_loc]
--				pos_x (type: float)
--					- X-position for south teleport destination
--				pos_y (type: float)
--					- Y-position for south teleport destination
--				pos_z (type: float)
--					- Z-position for south teleport destination
--				lvid (type: int, level vertex id)
--					- Level vertex id for south teleport destination
--				gvid (type: int, game vertex id)
--					- Game vertex id for south teleport destination
--
--	Return value (type: nil):
--		- none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 08, 2019
-- ------------------------------------------------------------------------------------------------

-- Text to display for an NPC offering river guide service:
function drx_ql_rg_transport_actor( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_river_guide.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to transport actor, cannot locate ini file" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to transport actor, npc is invalid" )
		return ""
	end

	-- Determine if north or south destination:
	local dest_loc = "south"
	local south_guide = (ini:r_string_ex( "river_guide_settings", "south_guide" ) or "")
	if ( npc:section( ) == south_guide ) then
		dest_loc = "north"
	end

	-- Get destination location info:
	local dest_loc_sect = string.format( "%s_dest_loc", dest_loc )
	local pos_x = (ini:r_float_ex( dest_loc_sect, "pos_x" ) or 0)
	local pos_y = (ini:r_float_ex( dest_loc_sect, "pos_y" ) or 0)
	local pos_z = (ini:r_float_ex( dest_loc_sect, "pos_z" ) or 0)
	local lvid = (ini:r_float_ex( dest_loc_sect, "lvid" ) or 0)
	local gvid = (ini:r_float_ex( dest_loc_sect, "gvid" ) or 0)

	-- Take river guide fee from actor:
	local npc_fee = (ini:r_float_ex( "river_guide_settings", "fee" ) or 0)
	db.actor:give_money( -(npc_fee) )
	if ( db.actor ) then
		news_manager.relocate_money( db.actor, "out", npc_fee )
	end

	-- End conversation:
	if ( (db.actor) and (db.actor:is_talking( )) ) then
		db.actor:stop_talk( )
	end

	-- Transport actor:
	printf( "DRX QL RG: River guide transporting actor to the %s", dest_loc )
	ChangeLevel( vector( ):set( pos_x, pos_y, pos_z ), lvid, gvid, vector( ):set( 0, 0, 0 ) )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_rg_offer_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines text to display for npc offering river guide service
--
--	Usage:
--		drx_ql_rg_offer_text( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_river_guide.ltx
--			[river_guide_settings]
--				fee (type: int, RU)
--					- River guide fee
--				south_guide (type: string, npc section name)
--					- Southern river guide
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_rg_north_dialog
--				- Text to display on northern river guide offering service
--			drx_ql_str_rg_south_dialog
--				- Text to display on southern river guide offering service
--
--	Return value (type: string):
--		- Returns the dialog text
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 08, 2019
-- ------------------------------------------------------------------------------------------------

-- Text to display for an NPC offering river guide service:
function drx_ql_rg_offer_text( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_river_guide.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to offer river guide service, cannot locate ini file" )
		return ""
	end

	-- Var to store return string:
	local retstring = ""

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	if ( not npc ) then
		printf( "DRX QL Error: Unable to offer river guide service, npc is invalid" )
		return ""
	end

	-- Determine if north or south river guide:
	local location = "north"
	local south_guide = (ini:r_string_ex( "river_guide_settings", "south_guide" ) or "")
	if ( npc:section( ) == south_guide ) then
		location = "south"
	end

	-- Format phrase:
	retstring = game.translate_string( string.format( "drx_ql_str_rg_%s_dialog", location ) )

	-- Add fee amount to dialog string:
	local npc_fee = (ini:r_float_ex( "river_guide_settings", "fee" ) or 0)
	retstring = string.format( retstring, npc_fee )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_rg_actor_has_fee function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has enough money to pay for river guide transport
--
--	Usage:
--		drx_ql_rg_actor_has_fee( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_river_guide.ltx
--			[river_guide_settings]
--				fee (type: int, RU)
--					- River guide fee
--
--	Return value (type: bool):
--		- Returns true if the actor has enough money to pay the fee, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 08, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has enough money to pay fee:
function drx_ql_rg_actor_has_fee( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_river_guide.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if actor has river guide fee, cannot locate ini file" )
		return false
	end

	-- Get the NPC fee:
	local fee = (ini:r_float_ex( "river_guide_settings", "fee" ) or 0)
	if ( db.actor:money( ) < fee ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_rg_actor_not_has_fee function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has enough money to pay for river guide transport
--
--	Usage:
--		drx_ql_rg_actor_not_has_fee( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		- Returns false if the actor has enough money to pay the fee, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 07, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine if actor has enough money to pay fee:
function drx_ql_rg_actor_not_has_fee( speaker_1, speaker_2 )

	-- Set return value:
	return ( not drx_ql_rg_actor_has_fee( speaker_1, speaker_2 ) )

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ht_reply_target_{x}_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for the npc replying about hidden target 1
--
--	Usage:
--		drx_ql_ht_reply_target_{x}_text( )
--			- {x} = int between 1 and 5
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_ht_specific_reply_area_{x}
--				- Text to display when npc reveals map hidden target can be found on ({x} = sequential int starting with 1)
--			drx_ql_str_ht_specific_reply_spot_{x}
--				- Text to display when npc reveals exact location of hidden target ({x} = sequential int starting with 1)
--			drx_ql_str_ht_specific_reply_unknown_{x}
--				- Text to display when npc does not know where the hidden target is ({x} = sequential int starting with 1)
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[ht_task_props]
--				ht_info_chance (type: float, decimal percent)
--					- Percent chance an NPC will have information on a hidden target
--
--	Return value (type: string):
--		Returns the text to display
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Text to display for the npc replying about hidden target 1:
function drx_ql_ht_reply_target_1_text( speaker_1, speaker_2 )
	return drx_ql_ht_reply_target_text( speaker_1, speaker_2, 1 )
end

-- Text to display for the npc replying about hidden target 2:
function drx_ql_ht_reply_target_2_text( speaker_1, speaker_2 )
	return drx_ql_ht_reply_target_text( speaker_1, speaker_2, 2 )
end

-- Text to display for the npc replying about hidden target 3:
function drx_ql_ht_reply_target_3_text( speaker_1, speaker_2 )
	return drx_ql_ht_reply_target_text( speaker_1, speaker_2, 3 )
end

-- Text to display for the npc replying about hidden target 4:
function drx_ql_ht_reply_target_4_text( speaker_1, speaker_2 )
	return drx_ql_ht_reply_target_text( speaker_1, speaker_2, 4 )
end

-- Text to display for the npc replying about hidden target 5:
function drx_ql_ht_reply_target_5_text( speaker_1, speaker_2 )
	return drx_ql_ht_reply_target_text( speaker_1, speaker_2, 5 )
end

-- Main function for text to display for the npc replying about hidden target:
function drx_ql_ht_reply_target_text( speaker_1, speaker_2, target_index )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate hidden target reply text, cannot locate ini file" )
		return ""
	end

	-- Determine if target knows location of hidden target:
	local info_chance = (ini:r_float_ex( "ht_task_props", "ht_info_chance" ) or 0)
	if ( (info_chance <= 0) or (math.random( ) > info_chance) ) then
		return game.translate_string( drx_ql_random_phrase( "drx_ql_str_ht_specific_reply_unknown" ) )
	end

	-- Get hidden target id:
	local hidden_target_id = nil
	local index = 1
	for target_id, task_id in pairs( xr_effects.drx_ql_hidden_targets ) do
		local se_obj = alife( ):object( target_id )
		if ( (se_obj) and (se_obj:alive( )) ) then
			if ( index == target_index ) then
				hidden_target_id = target_id
				break
			end
			index = (index + 1)
		end
	end

	-- Ensure a target was located:
	if ( not hidden_target_id ) then
		printf( "DRX QL Error: Unable to generate hidden target reply text, no valid target at index %s", target_index )
		return ""
	end

	-- Get the target object:
	local target_obj = alife( ):object( hidden_target_id )
	if ( not target_obj ) then
		printf( "DRX QL Error: Unable to generate hidden target reply text, target object at index %s is invalid", target_index )
		return ""
	end

	-- Check if the target is on the current level:
	if ( simulation_objects.is_on_the_same_level( target_obj, alife( ):actor( ) ) ) then
		xr_effects.drx_ql_hidden_targets[hidden_target_id] = nil
		return game.translate_string( drx_ql_random_phrase( "drx_ql_str_ht_specific_reply_spot" ) )
	end

	-- Get the level name the target is currently on:
	local level_name = game.translate_string( alife( ):level_name( game_graph( ):vertex( target_obj.m_game_vertex_id ):level_id( ) ) )

	-- Format phrase:
	local retstring = string.format( game.translate_string( drx_ql_random_phrase( "drx_ql_str_ht_specific_reply_area" ) ), level_name )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_ha_reply_target_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for the npc replying about hidden assassin
--
--	Usage:
--		drx_ql_ha_reply_target_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_ha_specific_reply_area_{x}
--				- Text to display when npc reveals map hidden assassin can be found on ({x} = sequential int starting with 1)
--			drx_ql_str_ha_specific_reply_spot_{x}
--				- Text to display when npc reveals exact location of hidden assassin ({x} = sequential int starting with 1)
--			drx_ql_str_ha_specific_reply_unknown_{x}
--				- Text to display when npc does not know where the hidden assassin is ({x} = sequential int starting with 1)
--
--	Persistent storage:
--		drx_ql_assassin_squad_id (type: squad id)
--			- Id of the assassin squad for a hunted task
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[hunted_task_props]
--				info_chance (type: float, decimal percent)
--					- Percent chance an NPC will have information on a hidden target
--
--	Return value (type: string):
--		Returns the text to display
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified February 17, 2019
-- ------------------------------------------------------------------------------------------------

-- Text to display for the npc replying about hidden assassin:
function drx_ql_ha_reply_target_text( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate hidden assassin reply text, cannot locate ini file" )
		return ""
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to generate hidden assassin reply text, db.actor not available" )
		return ""
	end

	-- Determine if target knows location of hidden assassin:
	local info_chance = (ini:r_float_ex( "hunted_task_props", "info_chance" ) or 0)
	if ( (info_chance <= 0) or (math.random( ) > info_chance) ) then
		return game.translate_string( drx_ql_random_phrase( "drx_ql_str_ha_specific_reply_unknown" ) )
	end

	-- Get hidden assassin id:
	local assassin_id
	local assassin_squad_id = utils.load_var( db.actor, "drx_ql_assassin_squad_id" )
	if ( assassin_squad_id ) then
		local assassin_squad_obj = alife_object( assassin_squad_id )
		if ( assassin_squad_obj ) then
			assassin_id = assassin_squad_obj:commander_id( )
		end
	end
	if ( not assassin_id ) then
		printf( "DRX QL Error: Unable to generate hidden assassin reply text, no valid assassin found" )
		return ""
	end

	-- Get the hidden assassin object:
	local assassin_obj = alife( ):object( assassin_id )
	if ( not assassin_obj ) then
		printf( "DRX QL Error: Unable to generate hidden assassin reply text, assassin object is invalid" )
		return ""
	end

	-- Check if the target is on the current level:
	if ( simulation_objects.is_on_the_same_level( assassin_obj, alife( ):actor( ) ) ) then
		db.actor:give_info_portion( "drx_ql_info_assassin_known" )
		return game.translate_string( drx_ql_random_phrase( "drx_ql_str_ha_specific_reply_spot" ) )
	end

	-- Get the level name the target is currently on:
	local level_name = game.translate_string( alife( ):level_name( game_graph( ):vertex( assassin_obj.m_game_vertex_id ):level_id( ) ) )

	-- Format phrase:
	local retstring = string.format( game.translate_string( drx_ql_random_phrase( "drx_ql_str_ha_specific_reply_area" ) ), level_name )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- STARTING TASK DIALOGS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_start_task_has_pre_desc_{x} functions
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not text is available for starting task pre-description dialogs
--
--	Usage:
--		drx_ql_start_task_has_pre_desc_{x}( )
--			- {x} = int from 1 to 3
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_start_task (type: string, task id)
--			Task id of the starting game task
--
--	Return value (type: bool):
--		Returns true if the text is available, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified May 06, 2018
-- ------------------------------------------------------------------------------------------------

-- Pre-description 1:
function drx_ql_start_task_has_pre_desc_1( speaker_1, speaker_2 )
	return drx_ql_start_task_has_pre_desc( speaker_1, speaker_2, 1 )
end
function drx_ql_start_task_dont_has_pre_desc_1( speaker_1, speaker_2 )
	return (not drx_ql_start_task_has_pre_desc_1( speaker_1, speaker_2 ))
end

-- Pre-description 2:
function drx_ql_start_task_has_pre_desc_2( speaker_1, speaker_2 )
	return drx_ql_start_task_has_pre_desc( speaker_1, speaker_2, 2 )
end
function drx_ql_start_task_dont_has_pre_desc_2( speaker_1, speaker_2 )
	return (not drx_ql_start_task_has_pre_desc_2( speaker_1, speaker_2 ))
end

-- Pre-description 3:
function drx_ql_start_task_has_pre_desc_3( speaker_1, speaker_2 )
	return drx_ql_start_task_has_pre_desc( speaker_1, speaker_2, 3 )
end
function drx_ql_start_task_dont_has_pre_desc_3( speaker_1, speaker_2 )
	return (not drx_ql_start_task_has_pre_desc_3( speaker_1, speaker_2 ))
end

-- Determine if task pre-description text is available:
function drx_ql_start_task_has_pre_desc( speaker_1, speaker_2, pre_desc_num )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if starting task pre-description dialog is available, db.actor not available" )
		return false
	end

	-- Get current task id:
	local task_id = utils.load_var( db.actor, "drx_ql_start_task" )
	if ( not task_id ) then
		printf( "DRX QL Error: Unable to determine if starting task pre-description dialog is available, no starting task available" )
		return false
	end

	-- Check if pre-description text exists:
	if ( (game.translate_string( string.format( "%s_pre_npc_%s", task_id, pre_desc_num ) ) == string.format( "%s_pre_npc_%s", task_id, pre_desc_num )) or (game.translate_string( string.format( "%s_pre_actor_%s", task_id, pre_desc_num ) ) == string.format( "%s_pre_actor_%s", task_id, pre_desc_num )) ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- TASK DESCRIPTION DIALOGS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_task_has_pre_desc_* functions
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not text is available for task pre-description dialogs
--
--	Usage:
--		drx_ql_task_has_pre_desc_{x}( )
--			- {x} = int from 1 to 3
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the text is available, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 31, 2019
-- ------------------------------------------------------------------------------------------------

-- Pre-description 1:
function drx_ql_task_has_pre_desc_1( speaker_1, speaker_2 )
	return drx_ql_task_has_pre_desc( speaker_1, speaker_2, 1 )
end
function drx_ql_task_dont_has_pre_desc_1( speaker_1, speaker_2 )
	return (not drx_ql_task_has_pre_desc_1( speaker_1, speaker_2 ))
end

-- Pre-description 2:
function drx_ql_task_has_pre_desc_2( speaker_1, speaker_2 )
	return drx_ql_task_has_pre_desc( speaker_1, speaker_2, 2 )
end
function drx_ql_task_dont_has_pre_desc_2( speaker_1, speaker_2 )
	return (not drx_ql_task_has_pre_desc_2( speaker_1, speaker_2 ))
end

-- Pre-description 3:
function drx_ql_task_has_pre_desc_3( speaker_1, speaker_2 )
	return drx_ql_task_has_pre_desc( speaker_1, speaker_2, 3 )
end
function drx_ql_task_dont_has_pre_desc_3( speaker_1, speaker_2 )
	return (not drx_ql_task_has_pre_desc_3( speaker_1, speaker_2 ))
end

-- Determine if task pre-description text is available:
function drx_ql_task_has_pre_desc( speaker_1, speaker_2, pre_desc_num )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if pre-task description text is available, npc id is invalid" )
		return false
	end

	-- Get current task id:
	local task_id = (axr_task_manager.available_tasks[npc_id] and axr_task_manager.available_tasks[npc_id][1])
	if ( not task_id ) then
		return false
	end

	-- Get the job descr string id:
	local desc_root = task_manager.task_ini:r_string_ex( task_id, "job_descr" )
	if ( (not desc_root) or (desc_root == "") ) then
		return false
	end

	-- Check if npc pre-description text exists:
	local npc_pre_desc_str_id = string.format( "%s_pre_npc_%s", desc_root, pre_desc_num )
	if ( game.translate_string( npc_pre_desc_str_id ) == npc_pre_desc_str_id ) then
		return false
	end

	-- Check if actor pre-description text exists:
	local actor_pre_desc_str_id = string.format( "%s_pre_actor_%s", desc_root, pre_desc_num )
	if ( game.translate_string( actor_pre_desc_str_id ) == actor_pre_desc_str_id ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_task_text_pre_desc_* functions
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Returns text for task pre-description dialogs
--
--	Usage:
--		drx_ql_task_text_pre_desc_{pre_desc_num}( )
--			- {pre_desc_num} = "actor_{x}" or "npc_{x}"
--			- {x} = int from 1 to 3
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: string, string id):
--		Returns the dialog text on success
--		Returns an empty string on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 31, 2019
-- ------------------------------------------------------------------------------------------------

-- Pre-description NPC 1:
function drx_ql_task_text_pre_desc_npc_1( speaker_1, speaker_2 )
	return drx_ql_task_text_pre_desc( speaker_1, speaker_2, "npc_1" )
end

-- Pre-description actor 1:
function drx_ql_task_text_pre_desc_actor_1( speaker_1, speaker_2 )
	return drx_ql_task_text_pre_desc( speaker_1, speaker_2, "actor_1" )
end

-- Pre-description NPC 2:
function drx_ql_task_text_pre_desc_npc_2( speaker_1, speaker_2 )
	return drx_ql_task_text_pre_desc( speaker_1, speaker_2, "npc_2" )
end

-- Pre-description actor 2:
function drx_ql_task_text_pre_desc_actor_2( speaker_1, speaker_2 )
	return drx_ql_task_text_pre_desc( speaker_1, speaker_2, "actor_2" )
end

-- Pre-description NPC 3:
function drx_ql_task_text_pre_desc_npc_3( speaker_1, speaker_2 )
	return drx_ql_task_text_pre_desc( speaker_1, speaker_2, "npc_3" )
end

-- Pre-description actor 3:
function drx_ql_task_text_pre_desc_actor_3( speaker_1, speaker_2 )
	return drx_ql_task_text_pre_desc( speaker_1, speaker_2, "actor_3" )
end

-- Get task pre-description dialog text:
function drx_ql_task_text_pre_desc( speaker_1, speaker_2, pre_desc_num )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to retreive actor pre-task description text, npc id is invalid" )
		return ""
	end

	-- Get current task id:
	local task_id = (axr_task_manager.available_tasks[npc_id] and axr_task_manager.available_tasks[npc_id][1])
	if ( not task_id ) then
		printf( "DRX QL Error: Unable to retreive actor pre-task description text, no stored task available" )
		return ""
	end

	-- Get the job descr string id:
	local desc_root = task_manager.task_ini:r_string_ex( task_id, "job_descr" )
	if ( (not desc_root) or (desc_root == "") ) then
		return ""
	end

	-- Get pre-description text:
	local pre_desc_text = string.format( "%s_pre_%s", desc_root, pre_desc_num )
	if ( not pre_desc_text ) then
		printf( "DRX QL Error: Unable to retreive pre-task description text, no text available" )
		return ""
	end

	-- Translate the text:
	pre_desc_text = game.translate_string( pre_desc_text )

	-- Set return value:
	return pre_desc_text

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_task_text_job_desc function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Returns text for task job description for NPC
--
--	Usage:
--		drx_ql_task_text_job_desc( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{task_id}_reward (type: object id)
--			- Name of task reward item
--		{task_id}_target_level (type: section name)
--			- Name of level the task target is on
--		drx_ql_{task_id}_{npc_id}_enemy_faction (type: string, faction name)
--			- Name of the enemy faction for the task
--
--	External strings:
--		configs\text\eng\drx_ql_strings.xml
--			drx_ql_str_{faction}_plural (type: string)
--				- Faction names used when referring to a faction as a whole
--
--	Return value (type: string, string id):
--		Returns the dialog text on success
--		Returns game.translate_string( "st_no_available_task" ) on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 25, 2019
-- ------------------------------------------------------------------------------------------------

-- Get task job description dialog text:
function drx_ql_task_text_job_desc( speaker_1, speaker_2 )

	-- Var to store return value:
	local job_desc_text = game.translate_string( "st_no_available_task" )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to retrieve job description text, db.actor not available" )
		return job_desc_text
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to retrieve job description text, npc id is invalid" )
		return job_desc_text
	end

	-- Get current task id:
	local task_id = (axr_task_manager.available_tasks[npc_id] and axr_task_manager.available_tasks[npc_id][1])
	if ( not task_id ) then
		return job_desc_text
	end
	local on_job_descr = task_manager.task_ini:r_string_ex( task_id, "on_job_descr" )
	if ( on_job_descr ) then
		local cond = xr_logic.parse_condlist( db.actor, "task_manager", "condlist", on_job_descr )
		if ( cond ) then
			xr_logic.pick_section_from_condlist( db.actor, db.actor, cond )
		end
	end

	-- Get job description modifiers:
	local fetch_descr = task_manager.task_ini:r_string_ex( task_id, "fetch_descr" )
	local level_text = utils.load_var( db.actor, string.format( "%s_target_level", task_id ) )
	local reward_text = utils.load_var( db.actor, string.format( "%s_reward", task_id ) )
	local enemy_faction = utils.load_var( db.actor, string.format( "drx_ql_%s_%s_enemy_faction", task_id, npc_id ) )

	-- Format fetch task job description:
	if ( fetch_descr ) then
		axr_task_manager.trigger_fetch_func( task_id )
		reward_text = utils.load_var( db.actor, string.format( "%s_reward", task_id ) )
		if ( reward_text ) then
			reward_text = game.translate_string( (system_ini( ):r_string_ex( reward_text, "inv_name" ) or "") )
		end
		if ( not reward_text ) then
			reward_text = ""
		end
		job_desc_text = string.format( game.translate_string( fetch_descr ), (dialogs._FETCH_TEXT or ""), reward_text )

	-- Format guide task job description:
	elseif ( level_text ) then
		level_text = game.translate_string( level_text )
		job_desc_text = string.format( game.translate_string( (task_manager.task_ini:r_string_ex( task_id, "job_descr" ) or "st_no_available_task") ), level_text )

	-- Format stored reward task job description:
	elseif ( reward_text ) then
		reward_text = game.translate_string( (system_ini( ):r_string_ex( reward_text, "inv_name" ) or "") )
		job_desc_text = string.format( game.translate_string( (task_manager.task_ini:r_string_ex( task_id, "job_descr" ) or "st_no_available_task") ), reward_text )

	-- Format dynamic brawl task job description:
	elseif ( enemy_faction ) then
		faction_text = game.translate_string( string.format( "drx_ql_str_%s_plural", enemy_faction ) )
		job_desc_text = string.format( game.translate_string( (task_manager.task_ini:r_string_ex( task_id, "job_descr" ) or "st_no_available_task") ), faction_text )

	-- Format task job description:
	else
		job_desc_text = game.translate_string( (task_manager.task_ini:r_string_ex( task_id, "job_descr" ) or "st_no_available_task") )

	end

	-- Set return value:
	return job_desc_text

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_end_game_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Returns text for NPC description of first endgame questline task
--
--	Usage:
--		drx_ql_end_game_text( )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_start_task (type: string, task id)
--			Task id of the starting game task
--
--	External strings:
--		drx_ql_strings_starting_tasks.xml
--			{starting_task_id}_endgame_{x}_text (type: string)
--				- NPC dialog to begin endgame questline ({x} = sequential int starting at 1)
--
--	Return value (type: string, string id):
--		Returns the dialog text on success
--		Returns game.translate_string( "st_no_available_task" ) on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 26, 2018
-- ------------------------------------------------------------------------------------------------

-- Get endgame questline first task dialog text:
function drx_ql_end_game_text( speaker_1, speaker_2 )

	-- Var to store return value:
	local retstring = game.translate_string( "st_no_available_task" )

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to retrieve endgame questline text, db.actor not available" )
		return retstring
	end

	-- Get the start game task id:
	local start_task = utils.load_var( db.actor, "drx_ql_start_task" )
	if ( not start_task ) then
		printf( "DRX QL Error: Unable to retrieve endgame questline text, start task id not found" )
		return retstring
	end

	-- Get count of available endgame task start phrases:
	local phrase_count = 0
	while ( true ) do
		if ( game.translate_string( string.format( "%s_endgame_%s_text", start_task, (phrase_count + 1) ) ) == string.format( "%s_endgame_%s_text", start_task, (phrase_count + 1) ) ) then
			break
		end
		phrase_count = (phrase_count + 1)
	end
	if ( phrase_count < 1 ) then
		printf( "DRX QL Error: Unable to retrieve endgame questline text, no endgame text found for %s", start_task )
		return retstring
	end

	-- Format the endgame task start text:
	retstring = string.format( "%s_endgame_%s_text", start_task, math.random( phrase_count ) )
	retstring = game.translate_string( retstring )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- UTILITY FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_random_phrase function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Picks a random phrase varient from a specified phrase group
--
--	Usage:
--		drx_ql_random_phrase( phrase_id )
--
--	Parameters:
--		phrase_id (type: string, string id without index)
--			- Phrase base id without index number suffix
--
--	Return value (type: string, string id):
--		Returns the string id of the selected phrase with index number suffix on success
--		Returns phrase_id on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 15, 2017
-- ------------------------------------------------------------------------------------------------

-- Select random phrase:
function drx_ql_random_phrase( phrase_id )

	-- Get count of available phrases:
	local phrase_count = 0
	while ( true ) do
		if ( game.translate_string( string.format( "%s_%s", phrase_id, (phrase_count + 1) ) ) == string.format( "%s_%s", phrase_id, (phrase_count + 1) ) ) then
			break
		end
		phrase_count = (phrase_count + 1)
	end

	-- Select random phrase:
	if ( phrase_count > 0 ) then
		phrase_id = string.format( "%s_%s", phrase_id, math.random( phrase_count ) )
	end

	-- Set return value:
	return phrase_id

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_npc_has_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not an npc has a generated task to offer
--		- Modification of dialogs.npc_has_task (CoC 1.5b r4)
--
--	Usage:
--		drx_ql_npc_has_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the npc has a task to offer, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 30, 2017
-- ------------------------------------------------------------------------------------------------

-- Check if NPC has task to offer:
function drx_ql_npc_has_task( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if NPC has available task, npc id is invalid" )
		return ""
	end

	-- Get current task id:
	local task_id = (axr_task_manager.available_tasks[npc_id] and axr_task_manager.available_tasks[npc_id][1])
	if ( not task_id ) then
		return false
	end

	-- Ensure the current task is not a meet honcho task:
	if ( string.find( task_id, "_meet_task_" ) ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_npc_dont_has_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not an npc has a generated task to offer
--
--	Usage:
--		drx_ql_npc_dont_has_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the npc has a task to offer, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 30, 2017
-- ------------------------------------------------------------------------------------------------

-- Check if NPC has task to offer:
function drx_ql_npc_dont_has_task( speaker_1, speaker_2 )

	-- Set return value:
	return (not drx_ql_npc_has_task( speaker_1, speaker_2 ))

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_npc_faction function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines the faction of an npc
--
--	Usage:
--		drx_ql_npc_faction( npc )
--
--	Parameters:
--		npc (type: obj)
--			- Npc object to get the faction of
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[questline_honchos] (type: string, npc name = cdl string, faction names)
--				- List of questline honchos to meet and their surrounding factions
--			[end_game_task]
--				meet_honcho (type: string, npc name)
--					- Honcho to meet to start the endgame questline
--				meet_honcho_faction (type: string)
--					- Unique (fake) faction to use for endgame honcho
--
--	Return value (type: string, faction name):
--		Returns the faction of the npc
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified January 31, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine npc faction:
function drx_ql_npc_faction( npc )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine npc faction, cannot locate ini file" )
		return
	end

	-- Get npc name:
	local npc_name
	if ( npc:section( ) == "m_trader" ) then
		npc_name = npc:name( )
	else
		npc_name = npc:section( )
	end

	-- Get npc faction:
	local npc_faction
	if ( npc_name == (ini:r_string_ex( "end_game_task", "meet_honcho" ) or "") ) then
		npc_faction = (ini:r_string_ex( "end_game_task", "meet_honcho_faction" ) or "")
	else
		local honcho_factions = alun_utils.parse_list( ini, "questline_honchos", npc_name )
		if ( (honcho_factions) and (#honcho_factions > 0) and (honcho_factions[1]) and (honcho_factions[1] ~= "") ) then
			npc_faction = honcho_factions[1]
		else
			npc_faction = character_community( npc )
		end
	end

	-- Set return value:
	return npc_faction

end
-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- SAFECRACKER TASK FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_reset_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Resets a safecracker task
--
--	Usage:
--		drx_ql_safecracker_reset_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Reset safecracker task:
function drx_ql_safecracker_reset_task( speaker_1, speaker_2 )

	-- Reset safecracker task global vars:
	drx_ql_safecracker_rewards = {}
	drx_ql_safecracker_current_item = nil
	drx_ql_safecracker_actor_items = 0
	drx_ql_safecracker_npc_items = 0

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_eligible function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not an npc can offer a safecracker task
--
--	Usage:
--		drx_ql_safecracker_eligible( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_npc_safecracker_eligible_{npc_id} (type: bool)
--			- Flag indicating whether or not the npc is safecracker eligible
--		drx_ql_npc_stored_task_time_{npc_id} (type: int, time)
--			- Time the npc stored task was first offered
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[sim_task_props]
--				stored_task_reset_time (type: int, seconds)
--					- Length of time NPC's store the same task before offering a new one
--			[safecracker_task_props]
--				case_item (type: string, quest item section name)
--					- Quest item that triggers safecracker task
--				safecracker_chance (type: float, decimal percent)
--					- Percent chance a NPC will offer a safecracker task
--			[safecracker_task_factions] (type: string, faction names)
--				- List of factions that can offer a safecracker task
--
--	Return value (type: bool):
--		Returns true if the npc can offer a safecracker task, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Check if NPC can offer safecracker task:
function drx_ql_safecracker_eligible( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if npc safecracker eligible, cannot locate ini file" )
		return false
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to determine if npc safecracker eligible, db.actor not available" )
		return false
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to determine if npc safecracker eligible, npc id is invalid" )
		return false
	end

	-- Get the safecracker case item:
	local case_item = ini:r_string_ex( "safecracker_task_props", "case_item" )
	if ( not case_item ) then
		printf( "DRX QL Error: Unable to determine if npc safecracker eligible, no case item found" )
		return false
	end

	-- Check if actor has safecracker case:
	if ( not db.actor:object( case_item ) ) then
		return false
	end

	-- Check if the npc task reset time has not yet elapsed:
	local time_last_checked = utils.load_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ) )
	local task_reset_time = (ini:r_float_ex( "sim_task_props", "stored_task_reset_time" ) or 0)
	if ( (time_last_checked) and (game.get_game_time( ):diffSec( time_last_checked ) < task_reset_time) ) then
		return utils.load_var( db.actor, string.format( "drx_ql_npc_safecracker_eligible_%s", npc_id ), false )
	end

	-- Check if npc is safecracker faction:
	local faction_eligible = false
	local safecracker_fations = alun_utils.collect_section( ini, "safecracker_task_factions" )
	if ( (safecracker_fations) and (#safecracker_fations >= 1) ) then
		local npc_faction = character_community( npc )
		for i = 1, ( #safecracker_fations ) do
			if ( npc_faction == safecracker_fations[i] ) then
				faction_eligible = true
				break
			end
		end
	end
	if ( not faction_eligible ) then
		return false
	end

	-- Decide if npc should be safecracker eligible:
	local safecracker_chance = (ini:r_float_ex( "safecracker_task_props", "safecracker_chance" ) or 0)
	if ( (not safecracker_chance) or (math.random( ) > safecracker_chance) ) then
		return false
	end

	-- Set npc to safecracker eligible and reset task time:
	utils.save_var( db.actor, string.format( "drx_ql_npc_safecracker_eligible_%s", npc_id ), true )
	utils.save_ctime( db.actor, string.format( "drx_ql_npc_stored_task_time_%s", npc_id ), game.get_game_time( ) )

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_ineligible function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not an npc can offer a safecracker task
--
--	Usage:
--		drx_ql_safecracker_ineligible( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the npc can offer a safecracker task, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Check if NPC can offer safecracker task:
function drx_ql_safecracker_ineligible( speaker_1, speaker_2 )
	return ( not drx_ql_safecracker_eligible( speaker_1, speaker_2 ) )
end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_actor_has_max function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has the max number of safecracker task reward items
--
--	Usage:
--		drx_ql_safecracker_actor_has_max( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[safecracker_task_props]
--				reward_count (type: int)
--					- Max actor reward item count for safecracker task
--
--	Return value (type: bool):
--		Returns true if the actor has max items, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Check if actor has max safecracker task items:
function drx_ql_safecracker_actor_has_max( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if actor has max safecracker reward items, cannot locate ini file" )
		return false
	end

	-- Get the reward item count:
	local reward_count = (ini:r_float_ex( "safecracker_task_props", "reward_count" ) or 0)

	-- Check if actor has been allocated max safecracker reward items:
	if ( drx_ql_safecracker_actor_items >= reward_count ) then
		return true
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_actor_not_has_max function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the actor has the max number of safecracker task reward items
--
--	Usage:
--		drx_ql_safecracker_actor_not_has_max( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the actor has max items, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Check if actor has max safecracker task items:
function drx_ql_safecracker_actor_not_has_max( speaker_1, speaker_2 )
	return ( not drx_ql_safecracker_actor_has_max( speaker_1, speaker_2 ) )
end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_npc_has_max function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the npc has the max item of safecracker task reward items
--
--	Usage:
--		drx_ql_safecracker_npc_has_max( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[safecracker_task_props]
--				reward_count (type: int)
--					- Max actor reward item count for safecracker task
--
--	Return value (type: bool):
--		Returns true if the npc has max items, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Check if npc has max safecracker task items:
function drx_ql_safecracker_npc_has_max( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to determine if npc has max safecracker reward items, cannot locate ini file" )
		return false
	end

	-- Get the reward item count:
	local reward_count = (ini:r_float_ex( "safecracker_task_props", "reward_count" ) or 0)

	-- Check if npc has been allocated max safecracker reward items:
	if ( drx_ql_safecracker_npc_items >= reward_count ) then
		return true
	end

	-- Set return value:
	return false

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_npc_not_has_max function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines if the npc has the max item of safecracker task reward items
--
--	Usage:
--		drx_ql_safecracker_npc_not_has_max( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns false if the npc has max items, true otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Check if npc has max safecracker task items:
function drx_ql_safecracker_npc_not_has_max( speaker_1, speaker_2 )
	return ( not drx_ql_safecracker_npc_has_max( speaker_1, speaker_2 ) )
end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_add_actor_item function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Increments the actor reward item count for a safecracker task
--
--	Usage:
--		drx_ql_safecracker_add_actor_item( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Increment safecracker actor item count:
function drx_ql_safecracker_add_actor_item( speaker_1, speaker_2 )

	-- Add current item to reward list:
	table.insert( drx_ql_safecracker_rewards, drx_ql_safecracker_current_item )

	-- Increment item count:
	drx_ql_safecracker_actor_items = (drx_ql_safecracker_actor_items + 1)

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_add_npc_item function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Increments the npc reward item count for a safecracker task
--
--	Usage:
--		drx_ql_safecracker_add_npc_item( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Increment safecracker npc item count:
function drx_ql_safecracker_add_npc_item( speaker_1, speaker_2 )

	-- Increment item count:
	drx_ql_safecracker_npc_items = (drx_ql_safecracker_npc_items + 1)

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_give_rewards function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Gives the actor safecracker task rewards
--
--	Usage:
--		drx_ql_safecracker_give_rewards( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[safecracker_task_props]
--				case_item (string, quest item section name)
--					- Quest item that triggers safecracker task
--				reward_count (type: int)
--					- Max actor reward item count for safecracker task
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Give actor safecracker rewards:
function drx_ql_safecracker_give_rewards( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to give safecracker task rewards, cannot locate ini file" )
		return
	end

	-- Get the reward item count:
	local reward_count = (ini:r_float_ex( "safecracker_task_props", "reward_count" ) or 0)

	-- Fill rest of reward array:
	local fill_count = (reward_count - #drx_ql_safecracker_rewards)
	if ( fill_count > 0 ) then
		for i = 1, ( fill_count ) do
			table.insert( drx_ql_safecracker_rewards, drx_ql_safecracker_pick_item( speaker_1, speaker_2 ) )
		end
	end

	-- Take case:
	local safecracker_case = ini:r_string_ex( "safecracker_task_props", "case_item" )
	if ( safecracker_case ) then
		xr_effects.remove_item( nil, nil, {safecracker_case} )
	end

	-- Give reward items:
	if ( #drx_ql_safecracker_rewards > 0 ) then
		for k = 1, ( #drx_ql_safecracker_rewards ) do
			xr_effects.reward_random_item( nil, nil, {drx_ql_safecracker_rewards[k]} )
		end
	end

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_pick_item function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Selects the current safecracker task item
--
--	Usage:
--		drx_ql_safecracker_pick_item( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[safecracker_task_props]
--				min_cost (type: int, RU)
--					- Minimum reward item cost
--				max_cost (type: int, RU)
--					- Maximum reward item cost
--			[safecracker_task_reward_sections] (type: string, reward section names)
--				- Safecracker task reward sections
--		drx\drx_ql_config.ltx
--			[{reward_item_section}] (type: string, item section names)
--				- Items to offer as task rewards
--
--	Return value (type: string, section name):
--		Returns the item section name and stores it in global var drx_ql_safecracker_current_item
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Select safecracker item:
function drx_ql_safecracker_pick_item( speaker_1, speaker_2 )

	-- Get the location of the main config file:
	local drx_ql_config_ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not drx_ql_config_ini ) then
		printf( "DRX QL Error: Unable to pick safecracker task item, Questlines config file not found" )
		return
	end

	-- Get the location of the items config file:
	local drx_ql_items_ini = ini_file( "drx\\drx_ql_items.ltx" )
	if ( not drx_ql_items_ini ) then
		printf( "DRX QL Error: Unable to pick safecracker task item, items config file not found" )
		return
	end

	-- Reward sections to use from the items config file:
	local reward_sections = alun_utils.collect_section( drx_ql_config_ini, "safecracker_task_reward_sections" )

	-- Get the minimum item cost:
	local min_cost = (drx_ql_config_ini:r_float_ex( "safecracker_task_props", "min_cost" ) or 0)

	-- Get the maximum item cost:
	local max_cost = (drx_ql_config_ini:r_float_ex( "safecracker_task_props", "max_cost" ) or 0)

	-- Build list of eligible items:
	local rewards_list = {}
	for i = 1, ( #reward_sections ) do

		-- Get the current section name:
		local current_section = reward_sections[i]

		-- Add eligible items from the current section to the reward list:
		local items_list = alun_utils.collect_section( drx_ql_items_ini, current_section )
		for k = 1, ( #items_list ) do

			-- Get the current item:
			local current_item = items_list[k]
			local item_cost = drx_ql_items_ini:r_float_ex( current_section, current_item )

			-- Determine if current item should be added to rewards list:
			if ( (item_cost >= min_cost) and (item_cost <= max_cost) ) then
				table.insert( rewards_list, current_item )
			end

		end

	end

	-- Ensure at least one item was found:
	if ( #rewards_list < 1 ) then
		printf( "DRX QL Error: Unable to pick safecracker item, no items available" )
		return
	end

	-- Pick item:
	drx_ql_safecracker_current_item = rewards_list[math.random( #rewards_list )]

	-- Set return value:
	return drx_ql_safecracker_current_item

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_present_item_{x}_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates npc text for presenting a safecracker task reward item
--
--	Usage:
--		drx_ql_safecracker_present_item_{x}_text( speaker_1, speaker_2 )
--			- {x} = int from 1 to 5
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_safecracker_npc_present_item_{x} (type: string)
--				- NPC dialog when presenting a safecracker text item ({x} = int from 1 to 5)
--
--	Return value (type: string):
--		Returns the npc dialog
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Generate text for presenting safecracker task reward item 1:
function drx_ql_safecracker_present_item_1_text( speaker_1, speaker_2 )
	return drx_ql_safecracker_present_item_text( speaker_1, speaker_2, 1 )
end

-- Generate text for presenting safecracker task reward item 2:
function drx_ql_safecracker_present_item_2_text( speaker_1, speaker_2 )
	return drx_ql_safecracker_present_item_text( speaker_1, speaker_2, 2 )
end

-- Generate text for presenting safecracker task reward item 3:
function drx_ql_safecracker_present_item_3_text( speaker_1, speaker_2 )
	return drx_ql_safecracker_present_item_text( speaker_1, speaker_2, 3 )
end

-- Generate text for presenting safecracker task reward item 4:
function drx_ql_safecracker_present_item_4_text( speaker_1, speaker_2 )
	return drx_ql_safecracker_present_item_text( speaker_1, speaker_2, 4 )
end

-- Generate text for presenting safecracker task reward item 5:
function drx_ql_safecracker_present_item_5_text( speaker_1, speaker_2 )
	return drx_ql_safecracker_present_item_text( speaker_1, speaker_2, 5 )
end

-- Main function to generate text for presenting safecracker task reward item:
function drx_ql_safecracker_present_item_text( speaker_1, speaker_2, item_number )

	-- Get the dialog string for the current item:
	local retstring = string.format( "drx_ql_str_safecracker_npc_present_item_%s", item_number )
	retstring = game.translate_string( retstring )

	-- Format the dialog:
	local item_name = (game.translate_string( system_ini( ):r_string_ex( drx_ql_safecracker_current_item, "inv_name" ) or "" ))
	retstring = string.format( retstring, item_name )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_open_safe_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates npc text for opening a safecracker task case
--
--	Usage:
--		drx_ql_safecracker_open_safe_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[safecracker_task_props]
--				reward_count (type: int)
--					- Max actor reward item count for safecracker task
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_safecracker_npc_open_safe (type: string)
--				- NPC dialog when opening a safecracker safe
--
--	Return value (type: string):
--		Returns the npc dialog
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Generate text for opening safecracker case:
function drx_ql_safecracker_open_safe_text( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate safecracker open safe dialog, cannot locate ini file" )
		return ""
	end

	-- Get the reward item count:
	local reward_count = (ini:r_float_ex( "safecracker_task_props", "reward_count" ) or 0)

	-- Format the dialog:
	local retstring = game.translate_string( "drx_ql_str_safecracker_npc_open_safe" )
	retstring = string.format( retstring, (reward_count * 2), reward_count )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_actor_max_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates npc text for actor having max safecracker task reward items
--
--	Usage:
--		drx_ql_safecracker_actor_max_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[safecracker_task_props]
--				reward_count (type: int)
--					- Max actor reward item count for safecracker task
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_safecracker_npc_max_items_actor (type: string)
--				- NPC dialog when actor has max safecracker task reward items
--
--	Return value (type: string):
--		Returns the npc dialog
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Generate text for actor having max items:
function drx_ql_safecracker_actor_max_text( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate safecracker task actor max items dialog, cannot locate ini file" )
		return ""
	end

	-- Get the reward item count:
	local reward_count = (ini:r_float_ex( "safecracker_task_props", "reward_count" ) or 0)

	-- Format the dialog:
	local retstring = game.translate_string( "drx_ql_str_safecracker_npc_max_items_actor" )
	retstring = string.format( retstring, reward_count )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_safecracker_npc_max_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates npc text for npc having max safecracker task reward items
--
--	Usage:
--		drx_ql_safecracker_npc_max_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[safecracker_task_props]
--				reward_count (type: int)
--					- Max actor reward item count for safecracker task
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_safecracker_npc_max_items_npc (type: string)
--				- NPC dialog when npc has max safecracker task reward items
--
--	Return value (type: string):
--		Returns the npc dialog
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified August 30, 2018
-- ------------------------------------------------------------------------------------------------

-- Generate text for npc having max items:
function drx_ql_safecracker_npc_max_text( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to generate safecracker task npc max items dialog, cannot locate ini file" )
		return ""
	end

	-- Get the reward item count:
	local reward_count = (ini:r_float_ex( "safecracker_task_props", "reward_count" ) or 0)

	-- Format the dialog:
	local retstring = game.translate_string( "drx_ql_str_safecracker_npc_max_items_npc" )
	retstring = string.format( retstring, reward_count )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- GENERAL NEWS FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_news_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Formats text for npc news dialog
--
--	Usage:
--		drx_ql_news_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		{NPC storage}:drx_ql_news_time_last_asked (type: int, time)
--			- Time the npc was last asked for news
--
--	Return value (type: string):
--		Returns the formatted text
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 27, 2019
-- ------------------------------------------------------------------------------------------------

-- Format news dialog text:
function drx_ql_news_text( speaker_1, speaker_2 )

	-- Var to store return string:
	local retstring = ""

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local actor = speaker_1
	if ( actor:id( ) == npc:id( ) ) then
		actor = speaker_2
	end

	-- Mark time asked for news:
	local time_last_checked = utils.save_ctime( npc, "drx_ql_news_time_last_asked", game.get_game_time( ) )

	-- Check if hunted task should be given:
	retstring = drx_ql_give_hunted_task( speaker_1, speaker_2 )

	-- Check if local warning can be given:
	if ( retstring == "" ) then
		retstring = drx_ql_give_local_warning( speaker_1, speaker_2 )
	end

	-- Check if find Oasis task can be given:
	if ( retstring == "" ) then
		retstring = drx_ql_give_oasis_task( speaker_1, speaker_2 )
	end

	-- If no phrases generated then give general news:
	if ( retstring == "" ) then

		-- Pick a general news type:
		local news_types = {"job", "anomalies", "information", "tips"}
		local news_type = news_types[math.random( #news_types )]

		-- Generate general news phrase:
		if ( news_type == "job" ) then
			local news_list = {}
			for k, v in pairs( dialog_manager.phrase_table[news_type] ) do
				if ( dialog_manager.precondition_job_dialogs( npc, actor, v.name, 0, v.id ) == true ) then
					table.insert( news_list, dialog_manager.phrase_table[news_type][k] )
				end
			end
			if ( #news_list > 0 ) then
				local phrs = news_list[math.random( #news_list )]
				retstring = phrs.name
				dialog_manager.action_job_dialogs( npc, actor, phrs.name, phrs.id )
			end
		elseif ( news_type == "anomalies" ) then
			local news_list = {}
			for k, v in pairs( dialog_manager.phrase_table[news_type] ) do
				if ( dialog_manager.precondition_anomalies_dialogs( npc, actor, v.name, 0, v.id ) == true ) then
					table.insert( news_list, dialog_manager.phrase_table[news_type][k] )
				end
			end
			if ( #news_list > 0 ) then
				local phrs = news_list[math.random( #news_list )]
				retstring = phrs.name
				dialog_manager.action_anomalies_dialogs( npc, actor, phrs.name, phrs.id )
			end
		elseif ( news_type == "information" ) then
			local news_list = {}
			for k, v in pairs( dialog_manager.phrase_table[news_type] ) do
				if ( dialog_manager.precondition_information_dialogs( npc, actor, v.name, 0, v.id ) == true ) then
					table.insert( news_list, dialog_manager.phrase_table[news_type][k] )
				end
			end
			if ( #news_list > 0 ) then
				local phrs = news_list[math.random( #news_list )]
				retstring = phrs.name
				dialog_manager.action_information_dialogs( npc, actor, phrs.name, phrs.id )
			end
		elseif ( news_type == "tips" ) then
			local news_list = {}
			for k, v in pairs( dialog_manager.phrase_table[news_type] ) do
				if ( dialog_manager.precondition_tips_dialogs( npc, actor, v.name, 0, v.id ) == true ) then
					table.insert( news_list, dialog_manager.phrase_table[news_type][k] )
				end
			end
			if ( #news_list > 0 ) then
				local phrs = news_list[math.random( #news_list )]
				retstring = phrs.name
				dialog_manager.action_tips_dialogs( npc, actor, phrs.name, phrs.id )
			end
		end

	end

	-- Give default reply if no other phrases found:
	if ( retstring == "" ) then
		retstring = string.format( "dm_no_more_%s", math.random( 1, 10 ) )
	end

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_give_hunted_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Gives the player a hunted task and formats hunted task text
--
--	Usage:
--		drx_ql_give_hunted_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Persistent storage:
--		drx_ql_assassin_squad_id (type: squad id)
--			- Id of the assassin squad for a hunted task
--		drx_ql_assassin_npc_id (type: npc id)
--			- Id of the assassin for a hunted task
--		drx_ql_hunted_task_giver_id (type: npc id)
--			- Id of the npc who gave hunted task
--		drx_ql_last_assassination_name (type: string)
--			- Character name of the last assassination target the player killed
--		drx_ql_last_assassination_time (type: ctime)
--			- Timestamp from the last assassination target the player killed
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[hunted_task_props]
--				task_id (type: string, task id)
--					- Task id of the player hunted task
--				timeout (type: float, seconds)
--					- Max length of time from last assassination to give hunted task
--				hunted_chance (type: float, decimal percent)
--					- Percent chance a hunted task will be given
--			[hunted_task_factions] (type: string, faction names)
--				- List of factions that can be assassins
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_hunted_warning (type: string)
--				- NPC warning player is wanted
--
--	Return value (type: string):
--		Returns the npc dialog text
--		Returns an empty string on failure or no task given
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 14, 2019
-- ------------------------------------------------------------------------------------------------

-- Give actor hunted task:
function drx_ql_give_hunted_task( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to give hunted task, cannot locate ini file" )
		return ""
	end

	-- Verify db.actor is available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Could not give hunted task, db.actor not available" )
		return ""
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to give hunted task, npc id is invalid" )
		return ""
	end

	-- Check if player already has hunted task:
	if ( db.actor:has_info( "drx_ql_info_has_hunted_task" ) ) then
		return ""
	end

	-- Check for a stored assassination victim:
	local victim_name = utils.load_var( db.actor, "drx_ql_last_assassination_name" )
	if ( not victim_name ) then
		return ""
	end

	-- Check if last assassination time expired:
	local assn_time = utils.load_ctime( db.actor, "drx_ql_last_assassination_time" )
	if ( not assn_time ) then
		utils.save_var( db.actor, "drx_ql_last_assassination_name", nil )
		return ""
	end
	local timeout = (ini:r_float_ex( "hunted_task_props", "timeout" ) or 0)
	if ( game.get_game_time( ):diffSec( assn_time ) > timeout ) then
		utils.save_var( db.actor, "drx_ql_last_assassination_name", nil )
		utils.save_ctime( db.actor, "drx_ql_last_assassination_time", nil )
		return ""
	end

	-- Random chance:
	local chance = (ini:r_float_ex( "hunted_task_props", "hunted_chance" ) or 0)
	if ( (not chance) or (math.random( ) > chance) ) then
		return ""
	end

	-- Build list of unoccupied smart terrains:
	local smart_list = {}
	for name, smart in pairs( SIMBOARD.smarts_by_names ) do

		-- Inspect next smart terrain:
		if ( simulation_objects.available_by_id[smart.id] == true ) then
			local smrt = SIMBOARD.smarts[smart.id]
			if ( smrt ) then

				-- Check if current smart is not on same level as actor:
				if ( game_graph( ):vertex( smart.m_game_vertex_id ):level_id( ) ~= game_graph( ):vertex( db.actor:game_vertex_id( ) ):level_id( ) ) then

					-- Check if current smart terrain is occupied:
					local smart_is_occupied = false
					for k, squad in pairs( smrt.squads ) do
						if ( (squad.id) and (alife( ):object( squad.id )) ) then
							smart_is_occupied = true
							break
						end
					end

					-- Add the current smart terrain to the list of unoccupied smarts:
					if ( (not smart_is_occupied) and (xr_conditions.drx_ql_smart_not_blacklisted( speaker_1, speaker_2, {name} )) and (xr_conditions.drx_ql_smart_not_scorched( speaker_1, speaker_2, {name} )) ) then
						table.insert( smart_list, smart.id )
					end

				end

			end
		end

	end

	-- Pick a random smart terrain to spawn the assassin at:
	if ( (not smart_list) or (#smart_list < 1) ) then
		printf( "DRX QL Error: Unable to give hunted task, no smart terrains available" )
		return ""
	end
	local spawn_smart_id = smart_list[math.random( #smart_list )]

	-- Pick an assassin squad to spawn:
	local factions_list = alun_utils.collect_section( ini, "hunted_task_factions" )
	if ( (not factions_list) or (#factions_list < 1) ) then
		printf( "DRX QL Error: Unable to give hunted task, no assassin factions specified" )
		return ""
	end
	local faction = factions_list[math.random( #factions_list )]
	local spawn_squad = string.format( "drx_ql_assassin_squad_%s", faction )

	-- Spawn the assassin squad:
	local spawn_smart = alife( ):object( spawn_smart_id )
	local assassin_squad = SIMBOARD:create_squad( spawn_smart, spawn_squad )
	if ( not assassin_squad ) then
		printf( "DRX QL Error: Unable to give hunted task, assassination squad could not be spawned" )
		return ""
	end

	-- Setup squad members:
	assassin_squad:set_squad_relation( game_relations.ENEMIES )
	for member in assassin_squad:squad_members( ) do
		local se_obj = (member.object or (member.id and alife( ):object( member.id )))
		if ( se_obj ) then
			SIMBOARD:setup_squad_and_group( se_obj )
		end
	end

	-- Set actor as assassin squad target:
	local cond_list = "actor"
	assassin_squad.action_condlist = alun_utils.parse_condlist( cond_list )
	assassin_squad.scripted_target = "actor"

	-- Store the assassination target id:
	utils.save_var( db.actor, "drx_ql_assassin_squad_id", assassin_squad.id )
	utils.save_var( db.actor, "drx_ql_assassin_npc_id", assassin_squad:commander_id( ) )

	-- Remove assassin known infoportion:
	disable_info( "drx_ql_info_assassin_known" )

	-- Give player hunted task:
	local task_id = ini:r_string_ex( "hunted_task_props", "task_id" )
	if ( (not task_id) or (task_id == "") ) then
		printf( "DRX QL Error: Unable to give hunted task, no task specified" )
		return ""
	end
	task_manager.get_task_manager( ):give_task( task_id )

	-- Store the task giver id:
	utils.save_var( db.actor, "drx_ql_hunted_task_giver_id", npc_id )

	-- Flag player as having hunted task:
	db.actor:give_info_portion( "drx_ql_info_has_hunted_task" )

	-- Send update to the console:
	printf( "DRX QL: Hunted task started" )

	-- Format hunted task text:
	local dialog_text = string.format( game.translate_string( "drx_ql_str_hunted_warning" ), victim_name )

	-- Set return value:
	return dialog_text

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_give_oasis_task function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Gives the player the find Oasis task and formats dialog text
--
--	Usage:
--		drx_ql_give_oasis_task( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[oasis_task_props]
--				task_id (type: string, task id)
--					- Task id of the find Oasis task
--				oasis_chance (type: float, decimal percent)
--					- Percent chance the find Oasis task will be given
--			[oasis_task_factions] (type: string, faction names)
--				- List of factions that get the find Oasis task
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_find_oasis (type: string)
--				- NPC dialog text on giving find Oasis task
--
--	Return value (type: string):
--		Returns the npc dialog text
--		Returns an empty string on failure or no task given
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified July 27, 2019
-- ------------------------------------------------------------------------------------------------

-- Give find Oasis task:
function drx_ql_give_oasis_task( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to give find Oasis task, cannot locate ini file" )
		return ""
	end

	-- Check if player already has find Oasis task:
	if ( has_alife_info( "drx_ql_info_has_oasis_task" ) or has_alife_info( "save_jup_b16_passed_labyrinth" ) ) then
		return ""
	end

	-- Get random chance for giving Oasis task:
	local oasis_chance = (ini:r_float_ex( "oasis_task_props", "oasis_chance" ) or 0)
	if ( (not oasis_chance) or (math.random( ) > oasis_chance) ) then
		return ""
	end

	-- Check if actor is allowable faction:
	local actor_faction = alife( ):actor( ):community( )
	if ( not actor_faction ) then
		return ""
	end
	actor_faction = string.gsub( actor_faction, "actor_", "" )
	local factions_list = alun_utils.collect_section( ini, "oasis_task_factions", true )
	if ( (not factions_list) or (not factions_list[actor_faction]) ) then
		return ""
	end

	-- Give find Oasis task:
	local task_id = ini:r_string_ex( "oasis_task_props", "task_id" )
	if ( (not task_id) or (task_id == "") ) then
		printf( "DRX QL Error: Unable to give find Oasis task, no task specified" )
		return ""
	end
	task_manager.get_task_manager( ):give_task( task_id, nil )
	give_info( "drx_ql_info_has_oasis_task" )

	-- Format Oasis task text:
	local dialog_text = game.translate_string( "drx_ql_str_find_oasis" )

	-- Set return value:
	return dialog_text

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_give_local_warning function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Generates npc warning dialog text about threats in the area
--
--	Usage:
--		drx_ql_give_local_warning( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[local_warning_props]
--				max_radius (type: float, meters)
--					- Max radius to search for local threats
--				warning_chance (type: float, decimal percent)
--					- Percent chance a npc will give a local warning
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_local_warning_mutant_{x} (type: string)
--				- NPC warning player of mutants in the area ({x} = sequential int starting with 1)
--			drx_ql_str_local_warning_faction_{x} (type: string)
--				- NPC warning player of enemies in the area ({x} = sequential int starting with 1)
--			drx_ql_str_direction_{dir} (type: string)
--				- Compass direction ({dir} = compass direction)
--			drx_ql_str_{faction_name}_plural (type: string)
--				- Faction name in reference to a group of members ({faction_name} = faction name)
--
--	Return value (type: string):
--		Returns the npc dialog text
--		Returns an empty string on failure or no threats found
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified February 20, 2019
-- ------------------------------------------------------------------------------------------------

-- Give local warning:
function drx_ql_give_local_warning( speaker_1, speaker_2 )

	-- Var to store return string:
	local retstring = ""

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to give local warning, cannot locate ini file" )
		return retstring
	end

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local actor = speaker_1
	if ( actor:id( ) == npc:id( ) ) then
		actor = speaker_2
	end

	-- Random chance
	local chance = (ini:r_float_ex( "local_warning_props", "warning_chance" ) or 0)
	if ( (not chance) or (chance < math.random( )) ) then
		return retstring
	end

	-- Build list of occupied smart terrains:
	local nearest_threat_smart
	local nearest_threat_faction
	local nearest_threat_dist = 0
	local max_dist = (ini:r_float_ex( "local_warning_props", "max_radius" ) or 0)
	if ( max_dist > 0 ) then
		for name, smart in pairs( SIMBOARD.smarts_by_names ) do

			-- Inspect next smart terrain:
			if ( (smart.online) and (simulation_objects.available_by_id[smart.id] == true) ) then
				local smrt = SIMBOARD.smarts[smart.id]
				if ( smrt ) then

					-- Check if current smart terrain is occupied by enemy:
					local smart_is_occupied = false
					for k, squad in pairs( smrt.squads ) do
						if ( (squad) and (squad.stay_time) and (squad.current_target_id) and (squad.current_target_id == smart.id) and (not squad:get_script_target( )) ) then
							local current_faction = squad.player_id
							if ( (is_squad_monster[current_faction]) or (relation_registry.community_relation( current_faction, alife( ):actor( ):community( ) ) <= game_relations.ENEMIES) ) then

								-- Get distance to actor:
								local nearest_smart_id = smart_terrain.nearest_to_actor_smart.id
								local nearest_smart_obj = alife( ):object( nearest_smart_id )
								if ( nearest_smart_obj ) then
									local dist = utils.graph_distance( nearest_smart_obj.m_game_vertex_id, smart.m_game_vertex_id )
									if ( dist <= max_dist ) then
										if ( (dist < nearest_threat_dist) or (nearest_threat_dist == 0) ) then
											nearest_threat_smart = name
											nearest_threat_faction = current_faction
											nearest_threat_dist = dist
										end
									end
								end
								break

							end

						end
					end

				end
			end
		end

	end

	-- Check if a threat area was found:
	if ( (not nearest_threat_dist) or (not nearest_threat_faction) or (not nearest_threat_smart) ) then
		return retstring
	end

	-- Get the threat area object:
	local threat_smart = SIMBOARD.smarts_by_names[nearest_threat_smart]
	if ( not threat_smart ) then
		return retstring
	end

	-- Get angle to threat:
	local dx = (threat_smart.position.x - actor:position( ).x)
	local dy = (threat_smart.position.z - actor:position( ).z)
	local radians = math.atan2( dy, dx )
	local angle = 0
	if ( radians ) then
		angle = (radians * 57)
		if ( angle < 0 ) then
			angle = (angle + 360)
		end
		if ( angle > 360 ) then
			angle = (angle - 360)
		end
	end

	-- Translate angle to text:
	local dir_string = ""
	if ( (angle >= 330) or (angle <= 30) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_east" )
	elseif ( (angle > 30) and (angle <= 60) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_northeast" )
	elseif ( (angle > 60) and (angle <= 120) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_north" )
	elseif ( (angle > 120) and (angle <= 150) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_northwest" )
	elseif ( (angle > 150) and (angle <= 210) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_west" )
	elseif ( (angle > 210) and (angle <= 240) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_southwest" )
	elseif ( (angle > 240) and (angle <= 300) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_south" )
	elseif ( (angle > 300) and (angle <= 330) ) then
		dir_string = game.translate_string( "drx_ql_str_direction_southeast" )
	else
		dir_string = game.translate_string( "drx_ql_str_direction_close" )
	end

	-- Generate warning text:
	if ( is_squad_monster[nearest_threat_faction] ) then
		retstring = drx_ql_random_phrase( "drx_ql_str_local_warning_mutant" )
		retstring = game.translate_string( retstring )
		retstring = string.format( retstring, dir_string )
	else
		retstring = drx_ql_random_phrase( "drx_ql_str_local_warning_faction" )
		retstring = game.translate_string( retstring )
		local faction_plural = game.translate_string( string.format( "drx_ql_str_%s_plural", nearest_threat_faction ) )
		retstring = string.format( retstring, faction_plural, dir_string )
	end

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- FIRST MEET FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_first_meet_has_pre_desc_{x} functions
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines whether or not text is available for first meet pre-description dialogs
--
--	Usage:
--		drx_ql_first_meet_has_pre_desc_{x}( )
--			- {x} = int from 1 to 3
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: bool):
--		Returns true if the text is available, false otherwise
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 01, 2019
-- ------------------------------------------------------------------------------------------------

-- Pre-description 1:
function drx_ql_first_meet_has_pre_desc_1( speaker_1, speaker_2 )
	return drx_ql_first_meet_has_pre_desc( speaker_1, speaker_2, 1 )
end
function drx_ql_first_meet_dont_has_pre_desc_1( speaker_1, speaker_2 )
	return (not drx_ql_first_meet_has_pre_desc( speaker_1, speaker_2, 1 ))
end

-- Pre-description 2:
function drx_ql_first_meet_has_pre_desc_2( speaker_1, speaker_2 )
	return drx_ql_first_meet_has_pre_desc( speaker_1, speaker_2, 2 )
end
function drx_ql_first_meet_dont_has_pre_desc_2( speaker_1, speaker_2 )
	return (not drx_ql_first_meet_has_pre_desc( speaker_1, speaker_2, 2 ))
end

-- Pre-description 3:
function drx_ql_first_meet_has_pre_desc_3( speaker_1, speaker_2 )
	return drx_ql_first_meet_has_pre_desc( speaker_1, speaker_2, 3 )
end
function drx_ql_first_meet_dont_has_pre_desc_3( speaker_1, speaker_2 )
	return (not drx_ql_first_meet_has_pre_desc( speaker_1, speaker_2, 3 ))
end

-- Determine if pre-description text is available:
function drx_ql_first_meet_has_pre_desc( speaker_1, speaker_2, pre_desc_num )

	-- Get npc squad:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local squad = get_object_squad( npc )
	if ( not squad ) then
		return false
	end
	local squad_name = squad:section_name( )
	if ( not squad_name ) then
		return false
	end

	-- Get stored forced dialog:
	local dialog_root = drx_ql_first_meet.drx_ql_first_meet_dialogs[squad_name]
	if ( not dialog_root ) then
		return false
	end

	-- Format actor pre-dec string id:
	local actor_string_id = string.format( "%s_pre_actor_%s", dialog_root, pre_desc_num )
	local npc_string_id = string.format( "%s_pre_npc_%s", dialog_root, pre_desc_num )

	-- Check if pre-description text exists:
	if ( (game.translate_string( actor_string_id ) == actor_string_id) or (game.translate_string( npc_string_id ) == npc_string_id) ) then
		return false
	end

	-- Set return value:
	return true

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_first_meet_pre_{speaker}_{x}_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Text to display for first meet dialogs
--
--	Usage:
--		drx_ql_first_meet_pre_{speaker}_{x}_text
--			- {speaker} = "actor" or "npc"
--			- {x} = int between 1 and 3
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: string):
--		Returns the text to display
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 03, 2019
-- ------------------------------------------------------------------------------------------------

-- Text to display for npc first meet greeting dialog:
function drx_ql_first_meet_npc( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "npc", 0 )
end

-- Text to display for actor first meet dialog pre 1:
function drx_ql_first_meet_pre_actor_1( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "actor", 1 )
end

-- Text to display for npc first meet dialog pre 1:
function drx_ql_first_meet_pre_npc_1( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "npc", 1 )
end

-- Text to display for actor first meet dialog pre 2:
function drx_ql_first_meet_pre_actor_2( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "actor", 2 )
end

-- Text to display for npc first meet dialog pre 2:
function drx_ql_first_meet_pre_npc_2( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "npc", 2 )
end

-- Text to display for actor first meet dialog pre 3:
function drx_ql_first_meet_pre_actor_3( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "actor", 3 )
end

-- Text to display for npc first meet dialog pre 3:
function drx_ql_first_meet_pre_npc_3( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "npc", 3 )
end

-- Text to display for actor first meet closing dialog:
function drx_ql_first_meet_actor( speaker_1, speaker_2 )
	return drx_ql_first_meet_pre( speaker_1, speaker_2, "actor", 0 )
end

-- Main function for first meet pre-desc dialogs:
function drx_ql_first_meet_pre( speaker_1, speaker_2, speaker, pre_desc_num )

	-- Var to store return string:
	local retstring = ""

	-- Get npc squad:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local squad = get_object_squad( npc )
	if ( not squad ) then
		return retstring
	end
	local squad_name = squad:section_name( )
	if ( not squad_name ) then
		return retstring
	end

	-- Get stored forced dialog:
	local dialog_root = drx_ql_first_meet.drx_ql_first_meet_dialogs[squad_name]
	if ( not dialog_root ) then
		return retstring
	end

	-- Format string id:
	if ( tonumber( pre_desc_num ) > 0 ) then
		retstring = string.format( "%s_pre_%s_%s", dialog_root, speaker, pre_desc_num )
	else
		retstring = string.format( "%s_%s", dialog_root, speaker )
	end

	-- Translate text:
	retstring = (game.translate_string( retstring ) or "")
	retstring = string.format( retstring, alife( ):actor( ):character_name( ) )

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_first_meet_end_dialog function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Ends a first meet dialog
--
--	Usage:
--		drx_ql_first_meet_end_dialog
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 02, 2019
-- ------------------------------------------------------------------------------------------------

-- End first meet dialog:
function drx_ql_first_meet_end_dialog( speaker_1, speaker_2 )

	-- Get npc squad:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local squad = get_object_squad( npc )
	if ( not squad ) then
		return
	end
	local squad_name = squad:section_name( )
	if ( not squad_name ) then
		return
	end

	-- Get actor:
	local actor = speaker_1
	if ( actor:id( ) == npc:id( ) ) then
		actor = speaker_2
	end

	-- Remove stored forced dialog:
	drx_ql_first_meet.drx_ql_first_meet_dialogs[squad_name] = nil

	-- Remove dialog initiated flag:
	drx_ql_first_meet.drx_ql_first_meet_dialog_initiated = false

	-- Restore default dialog:
	npc:restore_default_start_dialog( )
	npc:enable_trade( )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ________________________________________________________________________________________________
-- SURRENDER VICTIM FUNCTIONS-


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_surrender_victim_text function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Determines dialog text to display for a surrender victim and transfers victim gear to actor
--		- Modification of dialogs.surrender_victim_answers_*  (CoC 1.b5 r4)
--
--	Usage:
--		drx_ql_surrender_victim_text( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	External strings:
--		drx_ql_strings.xml
--			drx_ql_str_surrender_victim_response_{x} (type: string)
--				- Surrender victim response ({x} = sequential int starting at 1)
--
--	Return value (type: string):
--		Returns the text for the dialog speaker to display
--		Returns nil on failure
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 24, 2019
-- ------------------------------------------------------------------------------------------------

-- Determine the text to display for surrender victim:
function drx_ql_surrender_victim_text( speaker_1, speaker_2 )

	-- Generate surrender victim text:
	local retstring = game.translate_string( drx_ql_random_phrase( "drx_ql_str_surrender_victim_response" ) )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to generate surrender victim text, npc id is invalid" )
		return retstring
	end

	-- Give actor npc weapons:
	if ( db.actor ) then
		local function itr( npc, itm )
			if ( IsWeapon( itm ) ) then
				npc:transfer_item( itm, db.actor )
				news_manager.relocate_item( db.actor, "in", itm:section( ) )
			end
		end
		npc:iterate_inventory( itr, npc )
	end

	-- Give PDA:
	local r = math.random( )
	local sec = "itm_pda_common"
	if ( r <= 0.10 ) then
		sec = "itm_pda_rare"
	elseif (r <= 0.5) then
		sec = "itm_pda_uncommon"
	end
	dialogs.relocate_item_section_to_actor( speaker_1, speaker_2, sec, 1 )

	-- Give stash location:
	if ( coc_treasure_manager ) then
		coc_treasure_manager.create_random_stash( nil, strformat( game.translate_string( "st_itm_stash_of_character" ), npc:character_name( ) ) )
		if ( (has_alife_info( "achieved_silver_or_lead" )) and ((math.random( 1, 100 ) / 100) <= 0.33) ) then
			coc_treasure_manager.create_random_stash( nil, strformat( game.translate_string( "st_itm_stash_of_character" ), npc:character_name( ) ) )
		end
	else
		axr_dynamic_spawn.random_secret( )
	end

	-- Set return value:
	return retstring

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_surrender_give_medkit function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Heals surrender victim
--
--	Usage:
--		drx_ql_surrender_give_medkit( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified March 24, 2019
-- ------------------------------------------------------------------------------------------------

-- Heal surrender victim:
function drx_ql_surrender_give_medkit( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to heal surrender victim, npc id is invalid" )
		return
	end

	-- Heal surrender victim:
	alife( ):create( "medkit_script", npc:position( ), 0, 0, npc:id( ) )
	xr_wounded.unlock_medkit( npc )

	-- Make surrender victim neutral to actor:
	if ( db.actor ) then
		npc:force_set_goodwill( 0, db.actor )
	end

	-- Make victim panicked to actor:
	db.storage[npc:id( )].panicked_to_actor = true

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_take_npc_prisoner function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Makes the npc a prisoner of the actor
--
--	Usage:
--		drx_ql_take_npc_prisoner( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified November 16, 2019
-- ------------------------------------------------------------------------------------------------

-- Take NPC prisoner:
function drx_ql_take_npc_prisoner( speaker_1, speaker_2 )

	-- Get npc id:
	local npc = dialogs.who_is_npc( speaker_1, speaker_2 )
	local npc_id = npc:id( )
	if ( not npc_id ) then
		printf( "DRX QL Error: Unable to take npc prisoner, npc id is invalid" )
		return
	end

	-- Set victim surrendered:
	dialogs.set_victim_surrendered( speaker_1, speaker_2 )

	-- Get prisoner squad:
	local npc_obj = alife( ):object( npc_id )
	if ( not npc_obj ) then
		printf( "DRX QL Error: Unable to take npc prisoner, npc is invalid" )
		return
	end
	local squad = get_object_squad( npc_obj )
	if ( not squad ) then
		printf( "DRX QL Error: Unable to take npc prisoner, unable to get squad object" )
		return
	end

	-- Add prisoner squad as companions to actor:
	axr_companions.companion_squads[squad.id] = squad
	squad:set_squad_relation( game_relations.FRIENDS )
	SIMBOARD:assign_squad_to_smart( squad, nil )
	for member in squad:squad_members( ) do
		local member_obj = (member.id and (db.storage[member.id] and db.storage[member.id].object))
		if ( member_obj and member_obj:alive( ) ) then
			utils.se_obj_save_var( member.id, member.object:name( ), "companion", true )
			utils.se_obj_save_var( member.id, member.object:name( ), "companion_cannot_dismiss", true )
			utils.se_obj_save_var( member.id, member.object:name( ), "companion_cannot_teleport", nil )
			member_obj:inactualize_patrol_path( )
			axr_companions.setup_companion_logic( member_obj, db.storage[member.id], false, true )
		end
	end

	-- Remove force wounded flag:
	npc:disable_info_portion( "drx_ql_npc_make_force_wounded" )
	npc:disable_info_portion( "drx_ql_npc_is_force_wounded" )
	drx_ql_force_wounded.drx_ql_force_wound_npcs[npc:id( )] = nil

	-- Flag NPC as wounded prisoner:
	npc:give_info_portion( "drx_ql_npc_prisoner_needs_healed" )

	-- Break dialog:
	dialogs.break_dialog( speaker_1, speaker_2 )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


-- ////////////////////////////////////////////////////////////////////////////////////////////////
--
-- drx_ql_noah_take_money function
--
-- ------------------------------------------------------------------------------------------------
--
--	Description:
--		- Gives money to Noah during plateau task dialog
--
--	Usage:
--		drx_ql_noah_take_money( speaker_1, speaker_2 )
--
--	Parameters:
--		speaker_1 (type: obj)
--			- Speaker 1 engaged in the current dialog
--		speaker_2 (type: obj)
--			- Speaker 2 engaged in the current dialog
--
--	Ini requirements:
--		drx\drx_ql_config.ltx
--			[operation_fairway_props]
--				noah_payment (type: int, RU)
--					- Amount of money Noah will take if paid for information
--
--	Return value (type: nil):
--		none
--
-- ------------------------------------------------------------------------------------------------
--	Created by DoctorX
--	for DoctorX Questlines 2.0
--	Last modified October 20, 2019
-- ------------------------------------------------------------------------------------------------

-- Give Noah money:
function drx_ql_noah_take_money( speaker_1, speaker_2 )

	-- Location of the settings file:
	local ini = ini_file( "drx\\drx_ql_config.ltx" )
	if ( not ini ) then
		printf( "DRX QL Error: Unable to take Noah payment, cannot locate ini file" )
		return retstring
	end

	-- Ensure db.actor available:
	if ( not db.actor ) then
		printf( "DRX QL Error: Unable to take Noah payment, db.actor not available" )
		return
	end

	-- Determine money to take:
	local noah_payment = (ini:r_float_ex( "operation_fairway_props", "noah_payment" ) or 0)
	if ( db.actor:money( ) < noah_payment ) then
		noah_payment = math.floor( db.actor:money( ) / 2 )
	end

	-- Take money from actor:
	db.actor:give_money( -(noah_payment) )
	news_manager.relocate_money( db.actor, "out", noah_payment )

	-- Set return value:
	return

end

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
